{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Introduction","text":""},{"location":"#index","title":"Index","text":"<p>\ud83d\ude80 This is the official documentation for pubtools-sign.</p> <ul> <li>Installation instructions are available in the  Installation Guide.</li> <li>For a quick start, check out the Quick Start.</li> <li>For detailed information, refer to the User guide</li> <li>For developers, we have a Developer Guide that covers advanced topics and customization options.</li> </ul>"},{"location":"installation/","title":"Installation Guide","text":""},{"location":"installation/#installation-guide","title":"Installation Guide","text":"<p>Warning</p> <p>If you plan to use msg signer with amqps protocol, you need to install <code>python3-qpid-proton</code> provided by your package manager (e.g. <code>dnf install python3-qpid-proton</code> for Fedora). as vesion in pypi seems to not be built with SSL support. That's also the reason why the package is not listed in <code>requirements.txt</code>.</p>"},{"location":"installation/#relased-version","title":"Relased version","text":"<p>To install released version, you need to run </p><pre><code>pip install pubtools-sign\n</code></pre><p></p>"},{"location":"installation/#development-version","title":"Development version","text":"<p>To install the necessary dependencies for this project, you can use the following command: </p><pre><code>pip install -r requirements.txt\n</code></pre> To install the project itself, you can use the following command:<p></p> <pre><code>pip install .\n</code></pre>"},{"location":"installation/#optional-dependencies","title":"Optional dependencies","text":"<p>If you want to use cosign signer, cosign binary needs to be available in your <code>PATH</code>.</p>"},{"location":"quick-start/","title":"Quick Start","text":""},{"location":"quick-start/#quick-start","title":"Quick Start","text":"<p>Install the package (see Installation Guide for details).</p> <p>Create configuration file (<code>~/.pubtools-sign/config.yaml</code>, <code>/etc/pubtools-sign/config.yaml</code>  or any location specified by --config option). See Configuration for details.</p> <p>See User Guide for further details.</p>"},{"location":"developer/developer-guide/","title":"Developer Guide","text":""},{"location":"developer/developer-guide/#developer-guide","title":"Developer Guide","text":"<p>Signers:</p> <ul> <li>MsgSigner</li> <li>CosignSigner</li> </ul> <p>Clients:</p> <ul> <li>Messaging SendClient</li> <li>Messaging RecvClient</li> <li>Registry Client </li> </ul> <p>Models:</p> <ul> <li>Messaging Message</li> </ul> <p>Results:</p> <ul> <li>ClearSignResult</li> <li>ContainerSignResult</li> <li>SigningResults</li> </ul> <p>Operations:</p> <ul> <li>Container Sign Operation</li> <li>Clear Sign Operation</li> </ul>"},{"location":"developer/api/clients/msgrecvclient/","title":"RecvClient","text":""},{"location":"developer/api/clients/msgrecvclient/#recvclient","title":"RecvClient","text":"<p>               Bases: <code>Container</code></p> <p>Messaging receiver.</p> Source code in <code>pubtools/sign/clients/msg_recv_client.py</code> <pre><code>class RecvClient(Container):\n    \"\"\"Messaging receiver.\"\"\"\n\n    def __init__(\n        self,\n        uid: str,\n        topic: str,\n        message_ids: List[str],\n        id_key: str,\n        broker_urls: List[str],\n        cert: str,\n        ca_cert: str,\n        timeout: int,\n        retries: int,\n        errors: List[MsgError],\n        received: Dict[Any, Any],\n    ) -&gt; None:\n        \"\"\"Recv Client Initializer.\n\n        Args:\n            topic (str): Topic where to listen for incoming messages\n            message_ids (List[str]): List of awaited message ids\n            id_key (str): Attribute name in message body which is considered as id\n            broker_urls (List[str]): List of broker urls\n            cert (str): Messaging client certificate\n            ca_cert (str): Messaging ca certificate\n            timeout (int): Timeout for the messaging receiver\n            retries (int): How many attempts to retry receiving messages\n            errors (List[MsgError]): List of errors which occured during the process\n            received (Dict[Any, Any]): Mapping of received messages\n            uid (str): Unique identifier for the receiver\n        \"\"\"\n        self.message_ids = message_ids\n        self.recv: Dict[Any, Any] = received\n        self._errors: List[MsgError] = errors\n        self.topic = topic\n        self.message_ids = message_ids\n        self.id_key = id_key\n        self.broker_urls = broker_urls\n        self.cert = cert\n        self.ca_cert = ca_cert\n        self.timeout = timeout\n        self.uid = uid\n        self._retries = retries\n        handler = _RecvClient(\n            uid=uid,\n            topic=topic,\n            message_ids=message_ids,\n            id_key=id_key,\n            broker_urls=broker_urls,\n            cert=cert,\n            ca_cert=ca_cert,\n            timeout=timeout,\n            recv=self.recv,\n            errors=self._errors,\n        )\n        super().__init__(handler)\n        self._handler = handler\n\n    def get_errors(self) -&gt; List[MsgError]:\n        \"\"\"Get errors from receiver.\n\n        This method doesn't have any meaningfull usecase, it's only used for testing\n\n        Returns:\n            List[MsgError]: List of errors which occured during the process\n        \"\"\"\n        return self._errors  # pragma: no cover\n\n    def get_received(self) -&gt; Dict[Any, Any]:\n        \"\"\"Get received messages.\n\n        This method doesn't have any meaningfull usecase, it's only used for testing\n\n        Returns:\n            Dict[Any, Any]: Dictionary of received messages\n        \"\"\"\n        return self.recv  # pragma: no cover\n\n    def run(self) -&gt; Union[Dict[Any, Any], List[MsgError]]:  # type: ignore[override]\n        \"\"\"Run the receiver.\n\n        This method starts the receiver and waits for messages to be received.\n\n        Returns:\n            Union[Dict[Any, Any], List[MsgError]]: Dictionary of received messages if successful,\n            or a list of errors if any occurred.\n        \"\"\"\n        LOG.info(\"Running messaging receiver\")\n        if not len(self.message_ids):\n            LOG.warning(\"No messages to receive\")\n            return []\n        super().run()\n        if self._errors:\n            return self._errors\n        return self.recv\n\n    def close(self) -&gt; None:\n        \"\"\"Close receiver.\"\"\"\n        LOG.info(\"Closing messaging receiver\")\n        if self._handler:\n            cast(_RecvClient, self._handler).close()\n</code></pre>"},{"location":"developer/api/clients/msgrecvclient/#pubtools.sign.clients.msg_recv_client.RecvClient.__init__","title":"<code>__init__(uid, topic, message_ids, id_key, broker_urls, cert, ca_cert, timeout, retries, errors, received)</code>","text":"<p>Recv Client Initializer.</p> <p>Parameters:</p> Name Type Description Default <code>topic</code> <code>str</code> <p>Topic where to listen for incoming messages</p> required <code>message_ids</code> <code>List[str]</code> <p>List of awaited message ids</p> required <code>id_key</code> <code>str</code> <p>Attribute name in message body which is considered as id</p> required <code>broker_urls</code> <code>List[str]</code> <p>List of broker urls</p> required <code>cert</code> <code>str</code> <p>Messaging client certificate</p> required <code>ca_cert</code> <code>str</code> <p>Messaging ca certificate</p> required <code>timeout</code> <code>int</code> <p>Timeout for the messaging receiver</p> required <code>retries</code> <code>int</code> <p>How many attempts to retry receiving messages</p> required <code>errors</code> <code>List[MsgError]</code> <p>List of errors which occured during the process</p> required <code>received</code> <code>Dict[Any, Any]</code> <p>Mapping of received messages</p> required <code>uid</code> <code>str</code> <p>Unique identifier for the receiver</p> required Source code in <code>pubtools/sign/clients/msg_recv_client.py</code> <pre><code>def __init__(\n    self,\n    uid: str,\n    topic: str,\n    message_ids: List[str],\n    id_key: str,\n    broker_urls: List[str],\n    cert: str,\n    ca_cert: str,\n    timeout: int,\n    retries: int,\n    errors: List[MsgError],\n    received: Dict[Any, Any],\n) -&gt; None:\n    \"\"\"Recv Client Initializer.\n\n    Args:\n        topic (str): Topic where to listen for incoming messages\n        message_ids (List[str]): List of awaited message ids\n        id_key (str): Attribute name in message body which is considered as id\n        broker_urls (List[str]): List of broker urls\n        cert (str): Messaging client certificate\n        ca_cert (str): Messaging ca certificate\n        timeout (int): Timeout for the messaging receiver\n        retries (int): How many attempts to retry receiving messages\n        errors (List[MsgError]): List of errors which occured during the process\n        received (Dict[Any, Any]): Mapping of received messages\n        uid (str): Unique identifier for the receiver\n    \"\"\"\n    self.message_ids = message_ids\n    self.recv: Dict[Any, Any] = received\n    self._errors: List[MsgError] = errors\n    self.topic = topic\n    self.message_ids = message_ids\n    self.id_key = id_key\n    self.broker_urls = broker_urls\n    self.cert = cert\n    self.ca_cert = ca_cert\n    self.timeout = timeout\n    self.uid = uid\n    self._retries = retries\n    handler = _RecvClient(\n        uid=uid,\n        topic=topic,\n        message_ids=message_ids,\n        id_key=id_key,\n        broker_urls=broker_urls,\n        cert=cert,\n        ca_cert=ca_cert,\n        timeout=timeout,\n        recv=self.recv,\n        errors=self._errors,\n    )\n    super().__init__(handler)\n    self._handler = handler\n</code></pre>"},{"location":"developer/api/clients/msgrecvclient/#pubtools.sign.clients.msg_recv_client.RecvClient.close","title":"<code>close()</code>","text":"<p>Close receiver.</p> Source code in <code>pubtools/sign/clients/msg_recv_client.py</code> <pre><code>def close(self) -&gt; None:\n    \"\"\"Close receiver.\"\"\"\n    LOG.info(\"Closing messaging receiver\")\n    if self._handler:\n        cast(_RecvClient, self._handler).close()\n</code></pre>"},{"location":"developer/api/clients/msgrecvclient/#pubtools.sign.clients.msg_recv_client.RecvClient.get_errors","title":"<code>get_errors()</code>","text":"<p>Get errors from receiver.</p> <p>This method doesn't have any meaningfull usecase, it's only used for testing</p> <p>Returns:</p> Type Description <code>List[MsgError]</code> <p>List[MsgError]: List of errors which occured during the process</p> Source code in <code>pubtools/sign/clients/msg_recv_client.py</code> <pre><code>def get_errors(self) -&gt; List[MsgError]:\n    \"\"\"Get errors from receiver.\n\n    This method doesn't have any meaningfull usecase, it's only used for testing\n\n    Returns:\n        List[MsgError]: List of errors which occured during the process\n    \"\"\"\n    return self._errors  # pragma: no cover\n</code></pre>"},{"location":"developer/api/clients/msgrecvclient/#pubtools.sign.clients.msg_recv_client.RecvClient.get_received","title":"<code>get_received()</code>","text":"<p>Get received messages.</p> <p>This method doesn't have any meaningfull usecase, it's only used for testing</p> <p>Returns:</p> Type Description <code>Dict[Any, Any]</code> <p>Dict[Any, Any]: Dictionary of received messages</p> Source code in <code>pubtools/sign/clients/msg_recv_client.py</code> <pre><code>def get_received(self) -&gt; Dict[Any, Any]:\n    \"\"\"Get received messages.\n\n    This method doesn't have any meaningfull usecase, it's only used for testing\n\n    Returns:\n        Dict[Any, Any]: Dictionary of received messages\n    \"\"\"\n    return self.recv  # pragma: no cover\n</code></pre>"},{"location":"developer/api/clients/msgrecvclient/#pubtools.sign.clients.msg_recv_client.RecvClient.run","title":"<code>run()</code>","text":"<p>Run the receiver.</p> <p>This method starts the receiver and waits for messages to be received.</p> <p>Returns:</p> Type Description <code>Union[Dict[Any, Any], List[MsgError]]</code> <p>Union[Dict[Any, Any], List[MsgError]]: Dictionary of received messages if successful,</p> <code>Union[Dict[Any, Any], List[MsgError]]</code> <p>or a list of errors if any occurred.</p> Source code in <code>pubtools/sign/clients/msg_recv_client.py</code> <pre><code>def run(self) -&gt; Union[Dict[Any, Any], List[MsgError]]:  # type: ignore[override]\n    \"\"\"Run the receiver.\n\n    This method starts the receiver and waits for messages to be received.\n\n    Returns:\n        Union[Dict[Any, Any], List[MsgError]]: Dictionary of received messages if successful,\n        or a list of errors if any occurred.\n    \"\"\"\n    LOG.info(\"Running messaging receiver\")\n    if not len(self.message_ids):\n        LOG.warning(\"No messages to receive\")\n        return []\n    super().run()\n    if self._errors:\n        return self._errors\n    return self.recv\n</code></pre>"},{"location":"developer/api/clients/msgsendclient/","title":"SendClient","text":""},{"location":"developer/api/clients/msgsendclient/#sendclient","title":"SendClient","text":"<p>               Bases: <code>Container</code></p> <p>SendClient wrapper class.</p> Source code in <code>pubtools/sign/clients/msg_send_client.py</code> <pre><code>class SendClient(Container):\n    \"\"\"SendClient wrapper class.\"\"\"\n\n    def __init__(\n        self,\n        messages: List[MsgMessage],\n        broker_urls: List[str],\n        cert: str,\n        ca_cert: str,\n        retries: int,\n        errors: List[MsgError],\n        **kwargs: Dict[str, Any],\n    ) -&gt; None:\n        \"\"\"Send Client Initializer.\n\n        Args:\n            messages (List[MsgMessage]): List of messages to send.\n            broker_urls (List[str]): List of addresses of messaging broker.\n            cert (str): Path to messaging client key and certificate in PEM format.\n            ca_cert (str): Path to messaging CA certificate.\n            retries (int): Number of retries for sending messages.\n            errors (List[MsgError]): List of errors which occurred during the process.\n        \"\"\"\n        self.messages = messages\n        self.handler = _SendClient(\n            messages=messages, broker_urls=broker_urls, cert=cert, ca_cert=ca_cert, errors=errors\n        )\n        self._retries = retries\n        self._errors = errors\n        super().__init__(self.handler, **kwargs)\n\n    def run(self) -&gt; List[MsgError]:  # type: ignore[override]\n        \"\"\"Run the SendClient.\n\n        Returns:\n            List[MsgError]: List of errors that occurred during sending messages.\n        \"\"\"\n        errors_len = 0\n        if not len(self.messages):\n            LOG.warning(\"No messages to send\")\n            return []\n        for x in range(self._retries):\n            super().run()\n            if len(self._errors) == errors_len:\n                break\n            errors_len = len(self._errors)\n        else:\n            return self._errors\n        return []\n</code></pre>"},{"location":"developer/api/clients/msgsendclient/#pubtools.sign.clients.msg_send_client.SendClient.__init__","title":"<code>__init__(messages, broker_urls, cert, ca_cert, retries, errors, **kwargs)</code>","text":"<p>Send Client Initializer.</p> <p>Parameters:</p> Name Type Description Default <code>messages</code> <code>List[MsgMessage]</code> <p>List of messages to send.</p> required <code>broker_urls</code> <code>List[str]</code> <p>List of addresses of messaging broker.</p> required <code>cert</code> <code>str</code> <p>Path to messaging client key and certificate in PEM format.</p> required <code>ca_cert</code> <code>str</code> <p>Path to messaging CA certificate.</p> required <code>retries</code> <code>int</code> <p>Number of retries for sending messages.</p> required <code>errors</code> <code>List[MsgError]</code> <p>List of errors which occurred during the process.</p> required Source code in <code>pubtools/sign/clients/msg_send_client.py</code> <pre><code>def __init__(\n    self,\n    messages: List[MsgMessage],\n    broker_urls: List[str],\n    cert: str,\n    ca_cert: str,\n    retries: int,\n    errors: List[MsgError],\n    **kwargs: Dict[str, Any],\n) -&gt; None:\n    \"\"\"Send Client Initializer.\n\n    Args:\n        messages (List[MsgMessage]): List of messages to send.\n        broker_urls (List[str]): List of addresses of messaging broker.\n        cert (str): Path to messaging client key and certificate in PEM format.\n        ca_cert (str): Path to messaging CA certificate.\n        retries (int): Number of retries for sending messages.\n        errors (List[MsgError]): List of errors which occurred during the process.\n    \"\"\"\n    self.messages = messages\n    self.handler = _SendClient(\n        messages=messages, broker_urls=broker_urls, cert=cert, ca_cert=ca_cert, errors=errors\n    )\n    self._retries = retries\n    self._errors = errors\n    super().__init__(self.handler, **kwargs)\n</code></pre>"},{"location":"developer/api/clients/msgsendclient/#pubtools.sign.clients.msg_send_client.SendClient.run","title":"<code>run()</code>","text":"<p>Run the SendClient.</p> <p>Returns:</p> Type Description <code>List[MsgError]</code> <p>List[MsgError]: List of errors that occurred during sending messages.</p> Source code in <code>pubtools/sign/clients/msg_send_client.py</code> <pre><code>def run(self) -&gt; List[MsgError]:  # type: ignore[override]\n    \"\"\"Run the SendClient.\n\n    Returns:\n        List[MsgError]: List of errors that occurred during sending messages.\n    \"\"\"\n    errors_len = 0\n    if not len(self.messages):\n        LOG.warning(\"No messages to send\")\n        return []\n    for x in range(self._retries):\n        super().run()\n        if len(self._errors) == errors_len:\n            break\n        errors_len = len(self._errors)\n    else:\n        return self._errors\n    return []\n</code></pre>"},{"location":"developer/api/clients/registry/","title":"ContainerRegistryClient","text":""},{"location":"developer/api/clients/registry/#containerregistryclient","title":"ContainerRegistryClient","text":""},{"location":"developer/api/clients/registry/#pubtools.sign.clients.registry.AUTH_FILES","title":"<code>AUTH_FILES = ['${XDG_CONFIG_HOME}/containers/auth.json', '${HOME}/.docker/config.json', '${REGISTRY_AUTH_FILE}']</code>  <code>module-attribute</code>","text":"<p>Default authentication files to search for credentials in container registry client.</p>"},{"location":"developer/api/clients/registry/#pubtools.sign.clients.registry.AuthTokenWrapper","title":"<code>AuthTokenWrapper</code>  <code>dataclass</code>","text":"<p>Carrier of the auth token for container registry.</p> Source code in <code>pubtools/sign/clients/registry.py</code> <pre><code>@dataclasses.dataclass\nclass AuthTokenWrapper:\n    \"\"\"Carrier of the auth token for container registry.\"\"\"\n\n    token: str\n</code></pre>"},{"location":"developer/api/clients/registry/#pubtools.sign.clients.registry.ContainerRegistryClient","title":"<code>ContainerRegistryClient</code>","text":"<p>Client for interacting with container registries.</p> Source code in <code>pubtools/sign/clients/registry.py</code> <pre><code>class ContainerRegistryClient:\n    \"\"\"Client for interacting with container registries.\"\"\"\n\n    def __init__(\n        self,\n        username: Optional[str] = None,\n        password: Optional[str] = None,\n        auth_file: Optional[str] = None,\n        retries: int = 5,\n        log_level: str = \"INFO\",\n    ):\n        \"\"\"Initialize.\n\n        Args:\n            username (Optional[str]): Username for authentication.\n            password (Optional[str]): Password for authentication.\n            auth_file (Optional[str]): Path to the auth file.\n            retries (int): Number of retries for HTTP requests.\n        \"\"\"\n        self.username = username\n        self.password = password\n        self.auth_file = auth_file\n        self._session: Union[None, requests.Session] = None\n        self.retries = retries\n        set_log_level(LOG, log_level)\n\n    @property\n    def session(self) -&gt; requests.Session:\n        \"\"\"Get the session object.\n\n        Returns:\n            requests.Session: The session object for making HTTP requests.\n        \"\"\"\n        if not self._session:\n            self._session = requests.Session()\n            retries = Retry(\n                total=self.retries, backoff_factor=0.1, status_forcelist=[500, 502, 503, 504]\n            )\n            self._session.mount(\"http://\", HTTPAdapter(max_retries=retries))\n        return self._session\n\n    def resolve_authentication(self, image_reference: str) -&gt; Tuple[str, str]:\n        \"\"\"Resolve authentication for the given image reference.\n\n        When username and password are provided in registry client, they are used.\n        Otherwise `AUTH_FILES` are search for specific authentication\n        entry based on host of image reference.\n\n        Args:\n            image_reference (str): Image reference to resolve authentication for.\n\n        Returns:\n            Tuple[str, str]: Username and password for authentication.\n        \"\"\"\n        if self.username and self.password:\n            return (self.username, self.password)\n\n        parsed = urlparse(image_reference)\n        if not parsed.scheme:\n            parsed = urlparse(f\"docker://{image_reference}\")\n        registry = parsed.netloc\n        existing_auth_files = []\n        auth_files = AUTH_FILES if not self.auth_file else [self.auth_file] + AUTH_FILES\n        for af in auth_files:\n            if os.path.exists(os.path.expandvars(af)):\n                existing_auth_files.append(os.path.expandvars(af))\n        for eaf in existing_auth_files:\n            parsed_conf = json.load(open(os.path.expandvars(eaf)))\n            parsed_auths = parsed_conf.get(\"auths\")\n            if registry in parsed_auths:\n                auth = (\n                    base64.b64decode(parsed_auths.get(registry)[\"auth\"].encode(\"utf-8\"))\n                    .decode(\"utf-8\")\n                    .split(\":\")\n                )\n                auth_tuple = (auth[0], auth[1])\n                break\n        else:\n            raise ValueError(\"No authentication found\")\n        return auth_tuple\n\n    def authenticate_to_registry(self, image_reference: str, auth_header: str) -&gt; Union[str, Any]:\n        \"\"\"Ask for auth token based on given auth header.\n\n        Args:\n            image_reference (str): Image reference to resolve authentication for.\n            auth_header (str): Authentication header from the registry.\n\n        Returns:\n            str: Authentication token.\n        \"\"\"\n        _, _, value = auth_header.partition(\"Bearer\")\n        items = parse_http_list(value)\n        opts = parse_keqv_list(items)\n        unparse_parts = [\n            \"https\",\n            opts[\"realm\"].replace(\"https://\", \"\").split(\"/\", 1)[0],\n            opts[\"realm\"].replace(\"https://\", \"\").split(\"/\", 1)[1],\n            \"\",\n            urlencode({\"service\": opts[\"service\"], \"scope\": opts[\"scope\"]}),\n            \"\",\n        ]\n        auth_url = urlunparse(unparse_parts)\n        username, password = self.resolve_authentication(image_reference)\n        response = self.session.get(auth_url, auth=(username, password))\n\n        response.raise_for_status()\n        return response.json().get(\"token\")\n\n    def check_container_image_exists(\n        self, image_reference: str, auth_token: AuthTokenWrapper\n    ) -&gt; Tuple[bool, str]:\n        \"\"\"Check if the given container image exists.\n\n        Args:\n            image_reference (str): Image reference to check.\n            auth_token (AuthTokenWrapper): Authentication token.\n\n        Returns:\n            Tuple[bool, str]: [True, \"\"] if the image exists,\n            Tuple[False, &lt;error_message&gt;] otherwise.\n        \"\"\"\n        repo_ref, tag = image_reference.rsplit(\":\", 1)\n        registry, repo = repo_ref.split(\"/\", 1)\n        manifest_url = f\"https://{registry}/v2/{repo}/manifests/{tag}\"\n        headers = {\"Authorization\": f\"Bearer {auth_token.token}\"}\n        response = self.session.get(manifest_url, headers=headers)\n\n        if response.status_code == 200:\n            return True, \"\"\n        elif response.status_code == 401:\n            auth_header = response.headers[\"www-authenticate\"]\n            auth_token.token = self.authenticate_to_registry(image_reference, auth_header)\n            # Retry the original request with the token\n            headers = {\"Authorization\": f\"Bearer {auth_token.token}\"}\n            response = self.session.get(manifest_url, headers=headers)\n            if response.status_code == 200:\n                return True, \"\"\n            elif response.status_code == 404:\n                return False, \"\"\n            else:\n                LOG.error(f\"Unexpected Error: {response.status_code} - {response.text}\")\n                return False, f\"Unexpected Error: {response.status_code} - {response.text}\"\n        elif response.status_code == 404:\n            return False, \"\"\n        else:\n            LOG.error(f\"Unexpected Error: {response.status_code} - {response.text}\")\n            return False, f\"Unexpected Error: {response.status_code} - {response.text}\"\n</code></pre>"},{"location":"developer/api/clients/registry/#pubtools.sign.clients.registry.ContainerRegistryClient.session","title":"<code>session</code>  <code>property</code>","text":"<p>Get the session object.</p> <p>Returns:</p> Type Description <code>Session</code> <p>requests.Session: The session object for making HTTP requests.</p>"},{"location":"developer/api/clients/registry/#pubtools.sign.clients.registry.ContainerRegistryClient.__init__","title":"<code>__init__(username=None, password=None, auth_file=None, retries=5, log_level='INFO')</code>","text":"<p>Initialize.</p> <p>Parameters:</p> Name Type Description Default <code>username</code> <code>Optional[str]</code> <p>Username for authentication.</p> <code>None</code> <code>password</code> <code>Optional[str]</code> <p>Password for authentication.</p> <code>None</code> <code>auth_file</code> <code>Optional[str]</code> <p>Path to the auth file.</p> <code>None</code> <code>retries</code> <code>int</code> <p>Number of retries for HTTP requests.</p> <code>5</code> Source code in <code>pubtools/sign/clients/registry.py</code> <pre><code>def __init__(\n    self,\n    username: Optional[str] = None,\n    password: Optional[str] = None,\n    auth_file: Optional[str] = None,\n    retries: int = 5,\n    log_level: str = \"INFO\",\n):\n    \"\"\"Initialize.\n\n    Args:\n        username (Optional[str]): Username for authentication.\n        password (Optional[str]): Password for authentication.\n        auth_file (Optional[str]): Path to the auth file.\n        retries (int): Number of retries for HTTP requests.\n    \"\"\"\n    self.username = username\n    self.password = password\n    self.auth_file = auth_file\n    self._session: Union[None, requests.Session] = None\n    self.retries = retries\n    set_log_level(LOG, log_level)\n</code></pre>"},{"location":"developer/api/clients/registry/#pubtools.sign.clients.registry.ContainerRegistryClient.authenticate_to_registry","title":"<code>authenticate_to_registry(image_reference, auth_header)</code>","text":"<p>Ask for auth token based on given auth header.</p> <p>Parameters:</p> Name Type Description Default <code>image_reference</code> <code>str</code> <p>Image reference to resolve authentication for.</p> required <code>auth_header</code> <code>str</code> <p>Authentication header from the registry.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>Union[str, Any]</code> <p>Authentication token.</p> Source code in <code>pubtools/sign/clients/registry.py</code> <pre><code>def authenticate_to_registry(self, image_reference: str, auth_header: str) -&gt; Union[str, Any]:\n    \"\"\"Ask for auth token based on given auth header.\n\n    Args:\n        image_reference (str): Image reference to resolve authentication for.\n        auth_header (str): Authentication header from the registry.\n\n    Returns:\n        str: Authentication token.\n    \"\"\"\n    _, _, value = auth_header.partition(\"Bearer\")\n    items = parse_http_list(value)\n    opts = parse_keqv_list(items)\n    unparse_parts = [\n        \"https\",\n        opts[\"realm\"].replace(\"https://\", \"\").split(\"/\", 1)[0],\n        opts[\"realm\"].replace(\"https://\", \"\").split(\"/\", 1)[1],\n        \"\",\n        urlencode({\"service\": opts[\"service\"], \"scope\": opts[\"scope\"]}),\n        \"\",\n    ]\n    auth_url = urlunparse(unparse_parts)\n    username, password = self.resolve_authentication(image_reference)\n    response = self.session.get(auth_url, auth=(username, password))\n\n    response.raise_for_status()\n    return response.json().get(\"token\")\n</code></pre>"},{"location":"developer/api/clients/registry/#pubtools.sign.clients.registry.ContainerRegistryClient.check_container_image_exists","title":"<code>check_container_image_exists(image_reference, auth_token)</code>","text":"<p>Check if the given container image exists.</p> <p>Parameters:</p> Name Type Description Default <code>image_reference</code> <code>str</code> <p>Image reference to check.</p> required <code>auth_token</code> <code>AuthTokenWrapper</code> <p>Authentication token.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>Tuple[bool, str]: [True, \"\"] if the image exists,</p> <code>str</code> <p>Tuple[False, ] otherwise.</p> Source code in <code>pubtools/sign/clients/registry.py</code> <pre><code>def check_container_image_exists(\n    self, image_reference: str, auth_token: AuthTokenWrapper\n) -&gt; Tuple[bool, str]:\n    \"\"\"Check if the given container image exists.\n\n    Args:\n        image_reference (str): Image reference to check.\n        auth_token (AuthTokenWrapper): Authentication token.\n\n    Returns:\n        Tuple[bool, str]: [True, \"\"] if the image exists,\n        Tuple[False, &lt;error_message&gt;] otherwise.\n    \"\"\"\n    repo_ref, tag = image_reference.rsplit(\":\", 1)\n    registry, repo = repo_ref.split(\"/\", 1)\n    manifest_url = f\"https://{registry}/v2/{repo}/manifests/{tag}\"\n    headers = {\"Authorization\": f\"Bearer {auth_token.token}\"}\n    response = self.session.get(manifest_url, headers=headers)\n\n    if response.status_code == 200:\n        return True, \"\"\n    elif response.status_code == 401:\n        auth_header = response.headers[\"www-authenticate\"]\n        auth_token.token = self.authenticate_to_registry(image_reference, auth_header)\n        # Retry the original request with the token\n        headers = {\"Authorization\": f\"Bearer {auth_token.token}\"}\n        response = self.session.get(manifest_url, headers=headers)\n        if response.status_code == 200:\n            return True, \"\"\n        elif response.status_code == 404:\n            return False, \"\"\n        else:\n            LOG.error(f\"Unexpected Error: {response.status_code} - {response.text}\")\n            return False, f\"Unexpected Error: {response.status_code} - {response.text}\"\n    elif response.status_code == 404:\n        return False, \"\"\n    else:\n        LOG.error(f\"Unexpected Error: {response.status_code} - {response.text}\")\n        return False, f\"Unexpected Error: {response.status_code} - {response.text}\"\n</code></pre>"},{"location":"developer/api/clients/registry/#pubtools.sign.clients.registry.ContainerRegistryClient.resolve_authentication","title":"<code>resolve_authentication(image_reference)</code>","text":"<p>Resolve authentication for the given image reference.</p> <p>When username and password are provided in registry client, they are used. Otherwise <code>AUTH_FILES</code> are search for specific authentication entry based on host of image reference.</p> <p>Parameters:</p> Name Type Description Default <code>image_reference</code> <code>str</code> <p>Image reference to resolve authentication for.</p> required <p>Returns:</p> Type Description <code>Tuple[str, str]</code> <p>Tuple[str, str]: Username and password for authentication.</p> Source code in <code>pubtools/sign/clients/registry.py</code> <pre><code>def resolve_authentication(self, image_reference: str) -&gt; Tuple[str, str]:\n    \"\"\"Resolve authentication for the given image reference.\n\n    When username and password are provided in registry client, they are used.\n    Otherwise `AUTH_FILES` are search for specific authentication\n    entry based on host of image reference.\n\n    Args:\n        image_reference (str): Image reference to resolve authentication for.\n\n    Returns:\n        Tuple[str, str]: Username and password for authentication.\n    \"\"\"\n    if self.username and self.password:\n        return (self.username, self.password)\n\n    parsed = urlparse(image_reference)\n    if not parsed.scheme:\n        parsed = urlparse(f\"docker://{image_reference}\")\n    registry = parsed.netloc\n    existing_auth_files = []\n    auth_files = AUTH_FILES if not self.auth_file else [self.auth_file] + AUTH_FILES\n    for af in auth_files:\n        if os.path.exists(os.path.expandvars(af)):\n            existing_auth_files.append(os.path.expandvars(af))\n    for eaf in existing_auth_files:\n        parsed_conf = json.load(open(os.path.expandvars(eaf)))\n        parsed_auths = parsed_conf.get(\"auths\")\n        if registry in parsed_auths:\n            auth = (\n                base64.b64decode(parsed_auths.get(registry)[\"auth\"].encode(\"utf-8\"))\n                .decode(\"utf-8\")\n                .split(\":\")\n            )\n            auth_tuple = (auth[0], auth[1])\n            break\n    else:\n        raise ValueError(\"No authentication found\")\n    return auth_tuple\n</code></pre>"},{"location":"developer/api/models/msg/","title":"Messaging models","text":""},{"location":"developer/api/models/msg/#messaging-models","title":"Messaging models","text":""},{"location":"developer/api/models/msg/#pubtoolssignmodelsmsgmsgmessage","title":"pubtools.sign.models.msg.MsgMessage","text":"<p>Messaging message model.</p> <p>Attributes:</p> Name Type Description <code>headers</code> <code>Dict[str, Any]</code> <p>Headers of the message.</p> <code>address</code> <code>str</code> <p>Address to which the message is sent.</p> <code>body</code> <code>Dict[str, Any]</code> <p>Body of the message.</p> Source code in <code>pubtools/sign/models/msg.py</code> <pre><code>@dataclasses.dataclass\nclass MsgMessage:\n    \"\"\"Messaging message model.\n\n    Attributes:\n        headers (Dict[str, Any]): Headers of the message.\n        address (str): Address to which the message is sent.\n        body (Dict[str, Any]): Body of the message.\n    \"\"\"\n\n    headers: Dict[str, Any]\n    address: str\n    body: Dict[str, Any]\n</code></pre>"},{"location":"developer/api/operations/clear-sign-operation/","title":"ClearSignOperation","text":""},{"location":"developer/api/operations/clear-sign-operation/#clearsignoperation","title":"ClearSignOperation","text":"<p>               Bases: <code>SignOperation</code></p> <p>ClearsSignOperation model class.</p> Source code in <code>pubtools/sign/operations/clearsign.py</code> <pre><code>@dataclass\nclass ClearSignOperation(SignOperation):\n    \"\"\"ClearsSignOperation model class.\"\"\"\n\n    ResultType: ClassVar[OperationResult]\n    inputs: List[str] = field(\n        metadata={\n            \"type\": \"list\",\n            \"description\": \"Signing data\",\n            \"required\": \"true\",\n            \"sample\": [\"input1\", \"input2\"],\n        },\n        default_factory=list,\n    )\n    task_id: str = field(\n        metadata={\n            \"type\": \"str\",\n            \"description\": \"Usually pub task id, serves as identifier for in signing request\",\n            \"required\": \"true\",\n            \"sample\": \"1\",\n        },\n        default=\"\",\n    )\n    repo: str = field(\n        metadata={\n            \"type\": \"str\",\n            \"description\": \"Repository name\",\n            \"required\": \"true\",\n            \"sample\": \"repo\",\n        },\n        default=\"\",\n    )\n    requester: str = field(\n        metadata={\"description\": \"Requester of the signing operation\"}, default=\"\"\n    )\n\n    def to_dict(self) -&gt; dict[str, Any]:\n        \"\"\"Return a dict representation of the object.\"\"\"\n        return dict(\n            inputs=self.inputs,\n            signing_keys=self.signing_keys,\n            task_id=self.task_id,\n            repo=self.repo,\n            requester=self.requester,\n        )\n</code></pre>"},{"location":"developer/api/operations/clear-sign-operation/#pubtools.sign.operations.clearsign.ClearSignOperation.to_dict","title":"<code>to_dict()</code>","text":"<p>Return a dict representation of the object.</p> Source code in <code>pubtools/sign/operations/clearsign.py</code> <pre><code>def to_dict(self) -&gt; dict[str, Any]:\n    \"\"\"Return a dict representation of the object.\"\"\"\n    return dict(\n        inputs=self.inputs,\n        signing_keys=self.signing_keys,\n        task_id=self.task_id,\n        repo=self.repo,\n        requester=self.requester,\n    )\n</code></pre>"},{"location":"developer/api/operations/container-sign-operation/","title":"ContainerSignOperation","text":""},{"location":"developer/api/operations/container-sign-operation/#containersignoperation","title":"ContainerSignOperation","text":"<p>               Bases: <code>SignOperation</code></p> <p>ContainersSignOperation model class.</p> Source code in <code>pubtools/sign/operations/containersign.py</code> <pre><code>@dataclass\nclass ContainerSignOperation(SignOperation):\n    \"\"\"ContainersSignOperation model class.\"\"\"\n\n    ResultType: ClassVar[OperationResult]\n    digests: List[str] = field(\n        metadata={\"description\": \"List of digest to sign\"}, default_factory=list\n    )\n    references: List[str] = field(\n        metadata={\"description\": \"List of references to sign\"}, default_factory=list\n    )\n    task_id: str = field(\n        metadata={\n            \"description\": \"Usually pub task id, serves as identifier for in signing request\"\n        },\n        default=\"\",\n    )\n    identity_references: List[str] = field(\n        metadata={\"description\": \"List of references to sign\"}, default_factory=list\n    )\n    requester: str = field(\n        metadata={\"description\": \"Requester of the signing operation\"}, default=\"\"\n    )\n\n    def to_dict(self) -&gt; dict[str, Any]:\n        \"\"\"Return a dict representation of the object.\"\"\"\n        return dict(\n            digests=self.digests,\n            references=self.references,\n            signing_key_names=self.signing_key_names,\n            signing_keys=self.signing_keys,\n            task_id=self.task_id,\n            requester=self.requester,\n        )\n</code></pre>"},{"location":"developer/api/operations/container-sign-operation/#pubtools.sign.operations.containersign.ContainerSignOperation.to_dict","title":"<code>to_dict()</code>","text":"<p>Return a dict representation of the object.</p> Source code in <code>pubtools/sign/operations/containersign.py</code> <pre><code>def to_dict(self) -&gt; dict[str, Any]:\n    \"\"\"Return a dict representation of the object.\"\"\"\n    return dict(\n        digests=self.digests,\n        references=self.references,\n        signing_key_names=self.signing_key_names,\n        signing_keys=self.signing_keys,\n        task_id=self.task_id,\n        requester=self.requester,\n    )\n</code></pre>"},{"location":"developer/api/results/clearsignresult/","title":"ClearSignResult","text":""},{"location":"developer/api/results/clearsignresult/#clearsignresult","title":"ClearSignResult","text":"<p>               Bases: <code>OperationResult</code></p> <p>ClearOperationResult model.</p> <p>Attributes:</p> Name Type Description <code>outputs</code> <code>List[str]</code> <p>List of signing result outputs.</p> <code>signing_keys</code> <code>List[str]</code> <p>List of signing keys used during signing.</p> Source code in <code>pubtools/sign/results/clearsign.py</code> <pre><code>@dataclasses.dataclass()\nclass ClearSignResult(OperationResult):\n    \"\"\"ClearOperationResult model.\n\n    Attributes:\n        outputs (List[str]): List of signing result outputs.\n        signing_keys (List[str]): List of signing keys used during signing.\n    \"\"\"\n\n    outputs: List[str]\n    signing_keys: List[str]\n\n    def to_dict(self: Self) -&gt; Dict[Any, Any]:\n        \"\"\"Return dict representation of ClearOperationResult.\"\"\"\n        return {\"outputs\": self.outputs, \"signing_keys\": self.signing_keys}\n\n    @classmethod\n    def doc_arguments(cls: Type[Self]) -&gt; Dict[str, Any]:\n        \"\"\"Return dictionary with arguments description of the operation.\"\"\"\n        doc_arguments = {\n            \"operation_results\": {\n                \"type\": \"list\",\n                \"description\": \"Signing result output\",\n                \"returned\": \"always\",\n                \"sample\": [\"signed:'hello world'\"],\n            },\n            \"signing_keys\": {\n                \"type\": \"list\",\n                \"description\": \"The signing keys which is used during signing.\",\n                \"returned\": \"always\",\n                \"sample\": [\"123\"],\n            },\n        }\n\n        return doc_arguments\n</code></pre>"},{"location":"developer/api/results/clearsignresult/#pubtools.sign.results.clearsign.ClearSignResult.doc_arguments","title":"<code>doc_arguments()</code>  <code>classmethod</code>","text":"<p>Return dictionary with arguments description of the operation.</p> Source code in <code>pubtools/sign/results/clearsign.py</code> <pre><code>@classmethod\ndef doc_arguments(cls: Type[Self]) -&gt; Dict[str, Any]:\n    \"\"\"Return dictionary with arguments description of the operation.\"\"\"\n    doc_arguments = {\n        \"operation_results\": {\n            \"type\": \"list\",\n            \"description\": \"Signing result output\",\n            \"returned\": \"always\",\n            \"sample\": [\"signed:'hello world'\"],\n        },\n        \"signing_keys\": {\n            \"type\": \"list\",\n            \"description\": \"The signing keys which is used during signing.\",\n            \"returned\": \"always\",\n            \"sample\": [\"123\"],\n        },\n    }\n\n    return doc_arguments\n</code></pre>"},{"location":"developer/api/results/clearsignresult/#pubtools.sign.results.clearsign.ClearSignResult.to_dict","title":"<code>to_dict()</code>","text":"<p>Return dict representation of ClearOperationResult.</p> Source code in <code>pubtools/sign/results/clearsign.py</code> <pre><code>def to_dict(self: Self) -&gt; Dict[Any, Any]:\n    \"\"\"Return dict representation of ClearOperationResult.\"\"\"\n    return {\"outputs\": self.outputs, \"signing_keys\": self.signing_keys}\n</code></pre>"},{"location":"developer/api/results/containersignresult/","title":"ContainerSignResult","text":""},{"location":"developer/api/results/containersignresult/#containersignresult","title":"ContainerSignResult","text":"<p>               Bases: <code>OperationResult</code></p> <p>ContainerOperationResult model.</p> <p>Attributes:</p> Name Type Description <code>results</code> <code>List[str]</code> <p>List of signing result outputs.</p> <code>signing_keys</code> <code>List[str]</code> <p>The signing keys used during signing.</p> <code>failed</code> <code>bool</code> <p>Indicates if the operation failed.</p> Source code in <code>pubtools/sign/results/containersign.py</code> <pre><code>@dataclasses.dataclass\nclass ContainerSignResult(OperationResult):\n    \"\"\"ContainerOperationResult model.\n\n    Attributes:\n        results (List[str]): List of signing result outputs.\n        signing_keys (List[str]): The signing keys used during signing.\n        failed (bool): Indicates if the operation failed.\n    \"\"\"\n\n    ResultType: ClassVar[OperationResult]\n    results: List[str]\n    signing_keys: List[str]\n    failed: bool\n\n    def to_dict(self: Self) -&gt; Dict[Any, Any]:\n        \"\"\"Return dict representation of ContainerOperationResult.\"\"\"\n        return {\"results\": self.results, \"signing_keys\": self.signing_keys, \"failed\": self.failed}\n</code></pre>"},{"location":"developer/api/results/containersignresult/#pubtools.sign.results.containersign.ContainerSignResult.to_dict","title":"<code>to_dict()</code>","text":"<p>Return dict representation of ContainerOperationResult.</p> Source code in <code>pubtools/sign/results/containersign.py</code> <pre><code>def to_dict(self: Self) -&gt; Dict[Any, Any]:\n    \"\"\"Return dict representation of ContainerOperationResult.\"\"\"\n    return {\"results\": self.results, \"signing_keys\": self.signing_keys, \"failed\": self.failed}\n</code></pre>"},{"location":"developer/api/results/signingresults/","title":"SigningResults","text":""},{"location":"developer/api/results/signingresults/#signingresults","title":"SigningResults","text":""},{"location":"developer/api/results/signingresults/#pubtools.sign.results.signing_results.SigningResults","title":"<code>SigningResults</code>  <code>dataclass</code>","text":"<p>SigningResults model.</p> <p>Attributes:</p> Name Type Description <code>signer</code> <code>Signer</code> <p>The signer used for signing.</p> <code>operation</code> <code>SignOperation</code> <p>The operation performed by the signer.</p> <code>signer_results</code> <code>SignerResults</code> <p>Results from the signer.</p> <code>operation_result</code> <code>OperationResult</code> <p>Result of the operation.</p> Source code in <code>pubtools/sign/results/signing_results.py</code> <pre><code>@dataclasses.dataclass\nclass SigningResults:\n    \"\"\"SigningResults model.\n\n    Attributes:\n        signer (Signer): The signer used for signing.\n        operation (SignOperation): The operation performed by the signer.\n        signer_results (SignerResults): Results from the signer.\n        operation_result (OperationResult): Result of the operation.\n    \"\"\"\n\n    signer: Signer\n    operation: SignOperation\n    signer_results: SignerResults\n    operation_result: OperationResult\n</code></pre>"},{"location":"developer/api/signers/cosignsigner/","title":"CosignSigner","text":""},{"location":"developer/api/signers/cosignsigner/#cosignsigner","title":"CosignSigner","text":""},{"location":"developer/api/signers/cosignsigner/#pubtools.sign.signers.cosignsigner.CosignSigner","title":"<code>CosignSigner</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Signer</code></p> <p>Cosign signer class.</p> Source code in <code>pubtools/sign/signers/cosignsigner.py</code> <pre><code>@dataclass()\nclass CosignSigner(Signer):\n    \"\"\"Cosign signer class.\"\"\"\n\n    cosign_bin: str = field(\n        init=False,\n        metadata={\n            \"description\": \"Path to cosign binary\",\n            \"sample\": \"/usr/local/bin/cosign\",\n        },\n        default=\"/usr/bin/cosign\",\n    )\n\n    timeout: str = field(\n        init=False,\n        metadata={\n            \"description\": \"Timeout for cosign operations with units\",\n            \"sample\": \"60s\",\n        },\n        default=\"3m0s\",\n    )\n\n    num_threads: int = field(\n        init=False,\n        metadata={\n            \"description\": \"The number of threads for running cosign command\",\n            \"sample\": 10,\n        },\n        default=10,\n    )\n    allow_http_registry: bool = field(\n        init=False,\n        metadata={\n            \"description\": \"Allow http registry\",\n            \"sample\": False,\n        },\n        default=False,\n    )\n    allow_insecure_registry: bool = field(\n        init=False,\n        metadata={\n            \"description\": \"Allow insecure registry\",\n            \"sample\": False,\n        },\n        default=False,\n    )\n    rekor_url: str = field(\n        init=False,\n        metadata={\n            \"description\": \"URL for rekor stl server\",\n            \"sample\": \"https://rekor.sigstore.dev\",\n        },\n        default=\"https://rekor.sigstore.dev\",\n    )\n    env_variables: Dict[str, str] = field(\n        init=False,\n        metadata={\n            \"description\": \"environment variables used for signing\",\n            \"sample\": '{\"AWS_ACCESS_KEY_ID\": \"xxxxxxx\", \"AWS_SECRET_ACCESS_KEY\":\"yyyyyyyyy\"}',\n        },\n        default_factory=dict,\n    )\n    upload_tlog: bool = field(\n        init=False,\n        metadata={\"description\": \"upload signing record to rekor\", \"sample\": \"False\"},\n        default=True,\n    )\n\n    log_level: str = field(\n        init=False, metadata={\"description\": \"Log level\", \"sample\": \"debug\"}, default=\"info\"\n    )\n    key_aliases: Dict[str, str] = field(\n        init=False,\n        metadata={\n            \"description\": \"Aliases for signing keys\",\n            \"sample\": \"{'production':'abcde1245'}\",\n        },\n        default_factory=dict,\n    )\n\n    registry_user: str = field(\n        init=False,\n        metadata={\"description\": \"Registry basic user\", \"sample\": \"username\"},\n        default=\"\",\n    )\n\n    registry_password: str = field(\n        init=False,\n        metadata={\"description\": \"Registry basic password\", \"sample\": \"password\"},\n        default=\"\",\n    )\n    registry_auth_file: str = field(\n        init=False,\n        metadata={\"description\": \"Registry basic auth file\", \"sample\": \"auth.json\"},\n        default=\"\",\n    )\n    retries: int = field(\n        init=False,\n        metadata={\"description\": \"Number of retries for http requests\", \"sample\": 5},\n        default=5,\n    )\n\n    SUPPORTED_OPERATIONS: ClassVar[List[Type[SignOperation]]] = [\n        ContainerSignOperation,\n    ]\n\n    _signer_config_key: str = \"cosign_signer\"\n\n    def __post_init__(self) -&gt; None:\n        \"\"\"Post initialization of the class.\"\"\"\n        set_log_level(LOG, self.log_level)\n        self.container_registry_client = ContainerRegistryClient(\n            username=self.registry_user,\n            password=self.registry_password,\n            auth_file=self.registry_auth_file,\n            log_level=self.log_level,\n        )\n        self.auth_token = AuthTokenWrapper(token=\"\")\n\n    def load_config(self: CosignSigner, config_data: Dict[str, Any]) -&gt; None:\n        \"\"\"Load configuration of messaging signer.\n\n        Arguments:\n            config_data (dict): configuration data to load\n        \"\"\"\n        self.cosign_bin = config_data[\"cosign_signer\"].get(\"cosign_bin\", self.cosign_bin)\n        self.timeout = config_data[\"cosign_signer\"].get(\"timeout\", self.timeout)\n        self.allow_http_registry = config_data[\"cosign_signer\"].get(\n            \"allow_http_registry\", self.allow_http_registry\n        )\n        self.allow_insecure_registry = config_data[\"cosign_signer\"].get(\n            \"allow_insecure_registry\", self.allow_insecure_registry\n        )\n        self.rekor_url = config_data[\"cosign_signer\"].get(\"rekor_url\", self.rekor_url)\n        self.upload_tlog = config_data[\"cosign_signer\"].get(\"upload_tlog\", self.upload_tlog)\n        self.env_variables = config_data[\"cosign_signer\"].get(\"env_variables\", self.env_variables)\n        self.key_aliases = config_data[\"cosign_signer\"].get(\"key_aliases\", {})\n        self.registry_user = config_data[\"cosign_signer\"].get(\"registry_user\", self.registry_user)\n        self.registry_password = config_data[\"cosign_signer\"].get(\n            \"registry_password\", self.registry_password\n        )\n        self.retries = config_data[\"cosign_signer\"].get(\"retries\", self.retries)\n        self.container_registry_client = ContainerRegistryClient(\n            username=self.registry_user,\n            password=self.registry_password,\n            auth_file=self.registry_auth_file,\n            log_level=self.log_level,\n        )\n        self.num_threads = config_data[\"cosign_signer\"].get(\"num_threads\", self.num_threads)\n\n    def operations(self: CosignSigner) -&gt; List[Type[SignOperation]]:\n        \"\"\"Return list of supported signing operation classes.\n\n        Returns:\n            List[Type[SignOperation]]: list of supported operations\n        \"\"\"\n        return self.SUPPORTED_OPERATIONS\n\n    def _sign_container(\n        self,\n        args: List[str],\n        env: Dict[str, str],\n        tries: int,\n        identity: Optional[str] = None,\n        ref_digest: Optional[str] = None,\n        tag: Optional[str] = None,\n    ) -&gt; Any:\n        LOG.info(f\"Signing {identity} ({ref_digest}{tag or ''})\")\n        return run_command(args, env=env, tries=tries)\n\n    def sign(self: CosignSigner, operation: SignOperation) -&gt; SigningResults:\n        \"\"\"Run signing operation.\n\n        Arguments:\n            operation (SignOperation): signing operation to run\n\n        Returns:\n            SigningResults: results of the signing operation\n        \"\"\"\n        if isinstance(operation, ContainerSignOperation):\n            return self.container_sign(operation)\n        else:\n            raise UnsupportedOperation(operation)\n\n    def container_sign(self: CosignSigner, operation: ContainerSignOperation) -&gt; SigningResults:\n        \"\"\"Run container signing operation.\n\n        Arguments:\n            operation (ContainerSignOperation): container signing operation to run\n\n        Returns:\n            SigningResults: results of the container signing operation\n        \"\"\"\n        if operation.references and len(operation.digests) != len(operation.references):\n            raise ValueError(\"Digests must pair with references\")\n\n        signer_results = CosignSignerResults(status=\"ok\", error_message=\"\")\n\n        operation_result = ContainerSignResult(\n            signing_keys=operation.signing_keys, results=[], failed=False\n        )\n        signing_keys = operation.signing_keys\n\n        signing_results = SigningResults(\n            signer=self,\n            operation=operation,\n            signer_results=signer_results,\n            operation_result=operation_result,\n        )\n\n        for _signing_key in signing_keys:\n            if _signing_key in self.key_aliases:\n                signing_key = self.key_aliases[_signing_key]\n                LOG.info(f\"Using signing key alias {signing_key} for {_signing_key}\")\n            else:\n                signing_key = _signing_key\n\n            ref_args_group: dict[str, List[Tuple[List[str], Dict[str, Any]]]] = {}\n            common_args = [\n                self.cosign_bin,\n                \"-t\",\n                self.timeout,\n                \"sign\",\n                \"-y\",\n                \"--key\",\n                signing_key,\n                \"--allow-http-registry=%s\" % (\"true\" if self.allow_http_registry else \"false\"),\n                \"--allow-insecure-registry=%s\"\n                % (\"true\" if self.allow_insecure_registry else \"false\"),\n                \"--rekor-url\",\n                self.rekor_url,\n                \"--tlog-upload=%s\" % (\"true\" if self.upload_tlog else \"false\"),\n            ]\n            if self.registry_user:\n                common_args += [\"--registry-username\", self.registry_user]\n            if self.registry_password:\n                common_args += [\"--registry-password\", self.registry_password]\n            env_vars = os.environ.copy()\n            env_vars.update(self.env_variables)\n            if operation.references:\n                for ref, identity, digest in itertools.zip_longest(\n                    operation.references,\n                    operation.identity_references,\n                    operation.digests,\n                    fillvalue=\"\",\n                ):\n                    args = []\n                    named_args = {}\n                    if identity:\n                        args = [\"--sign-container-identity\", identity]\n                        named_args[\"identity\"] = identity\n                    repo, tag = ref.rsplit(\":\", 1)\n                    args.extend([\"-a\", f\"tag={tag}\", f\"{repo}@{digest}\"])\n                    named_args[\"tag\"] = tag\n                    # To avoid conflict caused by running in parallel for the same reference, group\n                    # args by reference.\n                    ref_digest = f\"{repo}@{digest}\"\n                    named_args[\"ref_digest\"] = digest\n\n                    ref_args_group.setdefault(ref_digest, [])\n                    ref_args_group[ref_digest].append((args, named_args))\n\n            else:\n                for ref_digest, identity in itertools.zip_longest(\n                    operation.digests, operation.identity_references, fillvalue=\"\"\n                ):\n                    args = []\n                    named_args = {}\n                    if identity:\n                        args = [\"--sign-container-identity\", identity]\n                        named_args[\"identity\"] = identity\n                    named_args[\"ref_digest\"] = ref_digest\n                    args.append(ref_digest)\n                    ref_args_group.setdefault(ref_digest, [])\n                    ref_args_group[ref_digest].append((args, named_args))\n\n            # Execute cosign commands serially in each group while running groups concurrently.\n            ret = run_in_parallel(\n                lambda args_group, **kwargs: [\n                    self._sign_container(\n                        common_args + args, env=env_vars, tries=self.retries, **kwargs\n                    )\n                    for args, kwargs in args_group\n                ],\n                [\n                    FData(\n                        args=[args_group],\n                    )\n                    for args_group in ref_args_group.values()\n                ],\n                self.num_threads,\n            )\n\n            for stdout, stderr, returncode in itertools.chain(*ret.values()):\n                if returncode != 0:\n                    operation_result.results.append(stderr)\n                    operation_result.failed = True\n                    signing_results.signer_results.status = \"failed\"\n                    signing_results.signer_results.error_message += stderr\n                else:\n                    operation_result.results.append(stderr)\n            signing_results.operation_result = operation_result\n        return signing_results\n\n    def existing_signatures(self, reference: str) -&gt; Tuple[bool, str]:\n        \"\"\"Return list of existing signatures for given reference.\n\n        Args:\n            reference (str): reference to get list of signatures for\n\n        Returns:\n            Tuple[bool, str]: tuple of success flag and error message or result string\n        \"\"\"\n        common_args = [\n            self.cosign_bin,\n            \"-t\",\n            self.timeout,\n            \"triangulate\",\n            \"--allow-http-registry=%s\" % (\"true\" if self.allow_http_registry else \"false\"),\n            \"--allow-insecure-registry=%s\" % (\"true\" if self.allow_insecure_registry else \"false\"),\n        ]\n        if self.registry_user:\n            common_args += [\"--registry-username\", self.registry_user]\n        if self.registry_password:\n            common_args += [\"--registry-password\", self.registry_password]\n        env_vars = os.environ.copy()\n        env_vars.update(self.env_variables)\n        stdout, stderr, returncode = run_command(\n            common_args + [reference],\n            env=env_vars,\n        )\n        if returncode != 0:\n            return False, stderr\n        else:\n            ret, err_msg = self.container_registry_client.check_container_image_exists(\n                stdout.strip(\"\\n\"), auth_token=self.auth_token\n            )\n            if ret:\n                return True, stdout.split(\"\\n\")\n            elif err_msg:\n                return False, err_msg\n            return True, \"\"\n</code></pre>"},{"location":"developer/api/signers/cosignsigner/#pubtools.sign.signers.cosignsigner.CosignSigner.__post_init__","title":"<code>__post_init__()</code>","text":"<p>Post initialization of the class.</p> Source code in <code>pubtools/sign/signers/cosignsigner.py</code> <pre><code>def __post_init__(self) -&gt; None:\n    \"\"\"Post initialization of the class.\"\"\"\n    set_log_level(LOG, self.log_level)\n    self.container_registry_client = ContainerRegistryClient(\n        username=self.registry_user,\n        password=self.registry_password,\n        auth_file=self.registry_auth_file,\n        log_level=self.log_level,\n    )\n    self.auth_token = AuthTokenWrapper(token=\"\")\n</code></pre>"},{"location":"developer/api/signers/cosignsigner/#pubtools.sign.signers.cosignsigner.CosignSigner.container_sign","title":"<code>container_sign(operation)</code>","text":"<p>Run container signing operation.</p> <p>Parameters:</p> Name Type Description Default <code>operation</code> <code>ContainerSignOperation</code> <p>container signing operation to run</p> required <p>Returns:</p> Name Type Description <code>SigningResults</code> <code>SigningResults</code> <p>results of the container signing operation</p> Source code in <code>pubtools/sign/signers/cosignsigner.py</code> <pre><code>def container_sign(self: CosignSigner, operation: ContainerSignOperation) -&gt; SigningResults:\n    \"\"\"Run container signing operation.\n\n    Arguments:\n        operation (ContainerSignOperation): container signing operation to run\n\n    Returns:\n        SigningResults: results of the container signing operation\n    \"\"\"\n    if operation.references and len(operation.digests) != len(operation.references):\n        raise ValueError(\"Digests must pair with references\")\n\n    signer_results = CosignSignerResults(status=\"ok\", error_message=\"\")\n\n    operation_result = ContainerSignResult(\n        signing_keys=operation.signing_keys, results=[], failed=False\n    )\n    signing_keys = operation.signing_keys\n\n    signing_results = SigningResults(\n        signer=self,\n        operation=operation,\n        signer_results=signer_results,\n        operation_result=operation_result,\n    )\n\n    for _signing_key in signing_keys:\n        if _signing_key in self.key_aliases:\n            signing_key = self.key_aliases[_signing_key]\n            LOG.info(f\"Using signing key alias {signing_key} for {_signing_key}\")\n        else:\n            signing_key = _signing_key\n\n        ref_args_group: dict[str, List[Tuple[List[str], Dict[str, Any]]]] = {}\n        common_args = [\n            self.cosign_bin,\n            \"-t\",\n            self.timeout,\n            \"sign\",\n            \"-y\",\n            \"--key\",\n            signing_key,\n            \"--allow-http-registry=%s\" % (\"true\" if self.allow_http_registry else \"false\"),\n            \"--allow-insecure-registry=%s\"\n            % (\"true\" if self.allow_insecure_registry else \"false\"),\n            \"--rekor-url\",\n            self.rekor_url,\n            \"--tlog-upload=%s\" % (\"true\" if self.upload_tlog else \"false\"),\n        ]\n        if self.registry_user:\n            common_args += [\"--registry-username\", self.registry_user]\n        if self.registry_password:\n            common_args += [\"--registry-password\", self.registry_password]\n        env_vars = os.environ.copy()\n        env_vars.update(self.env_variables)\n        if operation.references:\n            for ref, identity, digest in itertools.zip_longest(\n                operation.references,\n                operation.identity_references,\n                operation.digests,\n                fillvalue=\"\",\n            ):\n                args = []\n                named_args = {}\n                if identity:\n                    args = [\"--sign-container-identity\", identity]\n                    named_args[\"identity\"] = identity\n                repo, tag = ref.rsplit(\":\", 1)\n                args.extend([\"-a\", f\"tag={tag}\", f\"{repo}@{digest}\"])\n                named_args[\"tag\"] = tag\n                # To avoid conflict caused by running in parallel for the same reference, group\n                # args by reference.\n                ref_digest = f\"{repo}@{digest}\"\n                named_args[\"ref_digest\"] = digest\n\n                ref_args_group.setdefault(ref_digest, [])\n                ref_args_group[ref_digest].append((args, named_args))\n\n        else:\n            for ref_digest, identity in itertools.zip_longest(\n                operation.digests, operation.identity_references, fillvalue=\"\"\n            ):\n                args = []\n                named_args = {}\n                if identity:\n                    args = [\"--sign-container-identity\", identity]\n                    named_args[\"identity\"] = identity\n                named_args[\"ref_digest\"] = ref_digest\n                args.append(ref_digest)\n                ref_args_group.setdefault(ref_digest, [])\n                ref_args_group[ref_digest].append((args, named_args))\n\n        # Execute cosign commands serially in each group while running groups concurrently.\n        ret = run_in_parallel(\n            lambda args_group, **kwargs: [\n                self._sign_container(\n                    common_args + args, env=env_vars, tries=self.retries, **kwargs\n                )\n                for args, kwargs in args_group\n            ],\n            [\n                FData(\n                    args=[args_group],\n                )\n                for args_group in ref_args_group.values()\n            ],\n            self.num_threads,\n        )\n\n        for stdout, stderr, returncode in itertools.chain(*ret.values()):\n            if returncode != 0:\n                operation_result.results.append(stderr)\n                operation_result.failed = True\n                signing_results.signer_results.status = \"failed\"\n                signing_results.signer_results.error_message += stderr\n            else:\n                operation_result.results.append(stderr)\n        signing_results.operation_result = operation_result\n    return signing_results\n</code></pre>"},{"location":"developer/api/signers/cosignsigner/#pubtools.sign.signers.cosignsigner.CosignSigner.existing_signatures","title":"<code>existing_signatures(reference)</code>","text":"<p>Return list of existing signatures for given reference.</p> <p>Parameters:</p> Name Type Description Default <code>reference</code> <code>str</code> <p>reference to get list of signatures for</p> required <p>Returns:</p> Type Description <code>Tuple[bool, str]</code> <p>Tuple[bool, str]: tuple of success flag and error message or result string</p> Source code in <code>pubtools/sign/signers/cosignsigner.py</code> <pre><code>def existing_signatures(self, reference: str) -&gt; Tuple[bool, str]:\n    \"\"\"Return list of existing signatures for given reference.\n\n    Args:\n        reference (str): reference to get list of signatures for\n\n    Returns:\n        Tuple[bool, str]: tuple of success flag and error message or result string\n    \"\"\"\n    common_args = [\n        self.cosign_bin,\n        \"-t\",\n        self.timeout,\n        \"triangulate\",\n        \"--allow-http-registry=%s\" % (\"true\" if self.allow_http_registry else \"false\"),\n        \"--allow-insecure-registry=%s\" % (\"true\" if self.allow_insecure_registry else \"false\"),\n    ]\n    if self.registry_user:\n        common_args += [\"--registry-username\", self.registry_user]\n    if self.registry_password:\n        common_args += [\"--registry-password\", self.registry_password]\n    env_vars = os.environ.copy()\n    env_vars.update(self.env_variables)\n    stdout, stderr, returncode = run_command(\n        common_args + [reference],\n        env=env_vars,\n    )\n    if returncode != 0:\n        return False, stderr\n    else:\n        ret, err_msg = self.container_registry_client.check_container_image_exists(\n            stdout.strip(\"\\n\"), auth_token=self.auth_token\n        )\n        if ret:\n            return True, stdout.split(\"\\n\")\n        elif err_msg:\n            return False, err_msg\n        return True, \"\"\n</code></pre>"},{"location":"developer/api/signers/cosignsigner/#pubtools.sign.signers.cosignsigner.CosignSigner.load_config","title":"<code>load_config(config_data)</code>","text":"<p>Load configuration of messaging signer.</p> <p>Parameters:</p> Name Type Description Default <code>config_data</code> <code>dict</code> <p>configuration data to load</p> required Source code in <code>pubtools/sign/signers/cosignsigner.py</code> <pre><code>def load_config(self: CosignSigner, config_data: Dict[str, Any]) -&gt; None:\n    \"\"\"Load configuration of messaging signer.\n\n    Arguments:\n        config_data (dict): configuration data to load\n    \"\"\"\n    self.cosign_bin = config_data[\"cosign_signer\"].get(\"cosign_bin\", self.cosign_bin)\n    self.timeout = config_data[\"cosign_signer\"].get(\"timeout\", self.timeout)\n    self.allow_http_registry = config_data[\"cosign_signer\"].get(\n        \"allow_http_registry\", self.allow_http_registry\n    )\n    self.allow_insecure_registry = config_data[\"cosign_signer\"].get(\n        \"allow_insecure_registry\", self.allow_insecure_registry\n    )\n    self.rekor_url = config_data[\"cosign_signer\"].get(\"rekor_url\", self.rekor_url)\n    self.upload_tlog = config_data[\"cosign_signer\"].get(\"upload_tlog\", self.upload_tlog)\n    self.env_variables = config_data[\"cosign_signer\"].get(\"env_variables\", self.env_variables)\n    self.key_aliases = config_data[\"cosign_signer\"].get(\"key_aliases\", {})\n    self.registry_user = config_data[\"cosign_signer\"].get(\"registry_user\", self.registry_user)\n    self.registry_password = config_data[\"cosign_signer\"].get(\n        \"registry_password\", self.registry_password\n    )\n    self.retries = config_data[\"cosign_signer\"].get(\"retries\", self.retries)\n    self.container_registry_client = ContainerRegistryClient(\n        username=self.registry_user,\n        password=self.registry_password,\n        auth_file=self.registry_auth_file,\n        log_level=self.log_level,\n    )\n    self.num_threads = config_data[\"cosign_signer\"].get(\"num_threads\", self.num_threads)\n</code></pre>"},{"location":"developer/api/signers/cosignsigner/#pubtools.sign.signers.cosignsigner.CosignSigner.operations","title":"<code>operations()</code>","text":"<p>Return list of supported signing operation classes.</p> <p>Returns:</p> Type Description <code>List[Type[SignOperation]]</code> <p>List[Type[SignOperation]]: list of supported operations</p> Source code in <code>pubtools/sign/signers/cosignsigner.py</code> <pre><code>def operations(self: CosignSigner) -&gt; List[Type[SignOperation]]:\n    \"\"\"Return list of supported signing operation classes.\n\n    Returns:\n        List[Type[SignOperation]]: list of supported operations\n    \"\"\"\n    return self.SUPPORTED_OPERATIONS\n</code></pre>"},{"location":"developer/api/signers/cosignsigner/#pubtools.sign.signers.cosignsigner.CosignSigner.sign","title":"<code>sign(operation)</code>","text":"<p>Run signing operation.</p> <p>Parameters:</p> Name Type Description Default <code>operation</code> <code>SignOperation</code> <p>signing operation to run</p> required <p>Returns:</p> Name Type Description <code>SigningResults</code> <code>SigningResults</code> <p>results of the signing operation</p> Source code in <code>pubtools/sign/signers/cosignsigner.py</code> <pre><code>def sign(self: CosignSigner, operation: SignOperation) -&gt; SigningResults:\n    \"\"\"Run signing operation.\n\n    Arguments:\n        operation (SignOperation): signing operation to run\n\n    Returns:\n        SigningResults: results of the signing operation\n    \"\"\"\n    if isinstance(operation, ContainerSignOperation):\n        return self.container_sign(operation)\n    else:\n        raise UnsupportedOperation(operation)\n</code></pre>"},{"location":"developer/api/signers/cosignsigner/#pubtools.sign.signers.cosignsigner.CosignSignerResults","title":"<code>CosignSignerResults</code>  <code>dataclass</code>","text":"<p>               Bases: <code>SignerResults</code></p> <p>CosignSignerResults model.</p> Source code in <code>pubtools/sign/signers/cosignsigner.py</code> <pre><code>@dataclass()\nclass CosignSignerResults(SignerResults):\n    \"\"\"CosignSignerResults model.\"\"\"\n\n    status: str\n    error_message: str\n\n    def to_dict(self: SignerResults) -&gt; Dict[str, Any]:\n        \"\"\"Return dict representation of MsgSignerResults model.\"\"\"\n        return {\"status\": self.status, \"error_message\": self.error_message}\n\n    @classmethod\n    def doc_arguments(cls: Type[Self]) -&gt; Dict[str, Any]:\n        \"\"\"Return dictionary with result description of SignerResults.\"\"\"\n        doc_arguments = {\n            \"signer_result\": {\n                \"type\": \"dict\",\n                \"description\": \"Signing result status.\",\n                \"returned\": \"always\",\n                \"sample\": {\"status\": \"ok\", \"error_message\": \"\"},\n            }\n        }\n\n        return doc_arguments\n</code></pre>"},{"location":"developer/api/signers/cosignsigner/#pubtools.sign.signers.cosignsigner.CosignSignerResults.doc_arguments","title":"<code>doc_arguments()</code>  <code>classmethod</code>","text":"<p>Return dictionary with result description of SignerResults.</p> Source code in <code>pubtools/sign/signers/cosignsigner.py</code> <pre><code>@classmethod\ndef doc_arguments(cls: Type[Self]) -&gt; Dict[str, Any]:\n    \"\"\"Return dictionary with result description of SignerResults.\"\"\"\n    doc_arguments = {\n        \"signer_result\": {\n            \"type\": \"dict\",\n            \"description\": \"Signing result status.\",\n            \"returned\": \"always\",\n            \"sample\": {\"status\": \"ok\", \"error_message\": \"\"},\n        }\n    }\n\n    return doc_arguments\n</code></pre>"},{"location":"developer/api/signers/cosignsigner/#pubtools.sign.signers.cosignsigner.CosignSignerResults.to_dict","title":"<code>to_dict()</code>","text":"<p>Return dict representation of MsgSignerResults model.</p> Source code in <code>pubtools/sign/signers/cosignsigner.py</code> <pre><code>def to_dict(self: SignerResults) -&gt; Dict[str, Any]:\n    \"\"\"Return dict representation of MsgSignerResults model.\"\"\"\n    return {\"status\": self.status, \"error_message\": self.error_message}\n</code></pre>"},{"location":"developer/api/signers/cosignsigner/#pubtools.sign.signers.cosignsigner.cosign_container_sign","title":"<code>cosign_container_sign(signing_keys=[], config_file='', digest=[], reference=[], identity=[])</code>","text":"<p>Run containersign operation with cli arguments.</p> <p>Parameters:</p> Name Type Description Default <code>signing_key</code> <code>str</code> <p>path to the signing key</p> required <code>config_file</code> <code>str</code> <p>path to the config file</p> <code>''</code> <code>digest</code> <code>str</code> <p>digest of the image to sign</p> <code>[]</code> <code>reference</code> <code>str</code> <p>reference of the image to sign</p> <code>[]</code> <code>identity</code> <code>str</code> <p>identity to sign the image with</p> <code>[]</code> <p>Returns:     dict: signing result</p> Source code in <code>pubtools/sign/signers/cosignsigner.py</code> <pre><code>def cosign_container_sign(\n    signing_keys: List[str] = [],\n    config_file: str = \"\",\n    digest: List[str] = [],\n    reference: List[str] = [],\n    identity: List[str] = [],\n) -&gt; Dict[str, Any]:\n    \"\"\"Run containersign operation with cli arguments.\n\n    Args:\n        signing_key (str): path to the signing key\n        config_file (str): path to the config file\n        digest (str): digest of the image to sign\n        reference (str): reference of the image to sign\n        identity (str): identity to sign the image with\n    Returns:\n        dict: signing result\n    \"\"\"\n    cosign_signer = CosignSigner()\n    config = _get_config_file(config_file)\n    cosign_signer.load_config(load_config(os.path.expanduser(config)))\n\n    operation = ContainerSignOperation(\n        digests=digest,\n        references=reference,\n        identity_references=identity,\n        signing_keys=signing_keys,\n        task_id=\"\",\n    )\n    signing_result = cosign_signer.sign(operation)\n    return {\n        \"signer_result\": signing_result.signer_results.to_dict(),\n        \"operation_results\": signing_result.operation_result.results,\n        \"operation\": signing_result.operation.to_dict(),\n        \"signing_keys\": signing_result.operation_result.signing_keys,\n    }\n</code></pre>"},{"location":"developer/api/signers/cosignsigner/#pubtools.sign.signers.cosignsigner.cosign_container_sign_main","title":"<code>cosign_container_sign_main(signing_key=[], config_file='', digest=[], reference=[], identity=[], raw=False)</code>","text":"<p>Entry point method for containersign operation.</p> Source code in <code>pubtools/sign/signers/cosignsigner.py</code> <pre><code>@click.command()\n@click.option(\n    \"--signing-key\",\n    required=True,\n    help=\"signing key used by cosign.\",\n)\n@click.option(\"--config-file\", default=CONFIG_PATHS[0], help=\"path to the config file\")\n@click.option(\n    \"--digest\",\n    required=True,\n    multiple=True,\n    type=str,\n    help=\"Digests which should be signed.\",\n)\n@click.option(\n    \"--reference\",\n    required=False,\n    multiple=True,\n    type=str,\n    help=\"References which should be signed.\",\n)\n@click.option(\n    \"--identity\",\n    required=False,\n    multiple=True,\n    type=str,\n    help=\"Identity reference.\",\n)\n@click.option(\"--raw\", default=False, is_flag=True, help=\"Print raw output instead of json\")\ndef cosign_container_sign_main(\n    signing_key: List[str] = [],\n    config_file: str = \"\",\n    digest: List[str] = [],\n    reference: List[str] = [],\n    identity: List[str] = [],\n    raw: bool = False,\n) -&gt; None:\n    \"\"\"Entry point method for containersign operation.\"\"\"\n    ret = cosign_container_sign(\n        signing_keys=signing_key,\n        config_file=config_file,\n        digest=digest,\n        reference=reference,\n        identity=identity,\n    )\n    if not raw:\n        click.echo(json.dumps(ret))\n        if ret[\"signer_result\"][\"status\"] == \"error\":\n            sys.exit(1)\n    else:\n        if ret[\"signer_result\"][\"status\"] == \"error\":\n            print(ret[\"signer_result\"][\"error_message\"], file=sys.stderr)\n            sys.exit(1)\n        else:\n            for claim in ret[\"operation_results\"]:\n                print(claim)\n</code></pre>"},{"location":"developer/api/signers/cosignsigner/#pubtools.sign.signers.cosignsigner.cosign_list_existing_signatures","title":"<code>cosign_list_existing_signatures(config_file, reference)</code>","text":"<p>List existing signatures for given reference.</p> <p>Parameters:</p> Name Type Description Default <code>config_file</code> <code>str</code> <p>path to the config file</p> required <code>reference</code> <code>str</code> <p>reference to get list of signatures for</p> required <p>Returns:     Tuple[bool, str]: tuple of success flag and error message or result string</p> Source code in <code>pubtools/sign/signers/cosignsigner.py</code> <pre><code>def cosign_list_existing_signatures(config_file: str, reference: str) -&gt; Tuple[bool, str]:\n    \"\"\"List existing signatures for given reference.\n\n    Args:\n        config_file (str): path to the config file\n        reference (str): reference to get list of signatures for\n    Returns:\n        Tuple[bool, str]: tuple of success flag and error message or result string\n    \"\"\"\n    cosign_signer = CosignSigner()\n    config = _get_config_file(config_file)\n    cosign_signer.load_config(load_config(os.path.expanduser(config)))\n    return cosign_signer.existing_signatures(reference)\n</code></pre>"},{"location":"developer/api/signers/msgsigner/","title":"MsgSigner","text":""},{"location":"developer/api/signers/msgsigner/#msgsigner","title":"MsgSigner","text":""},{"location":"developer/api/signers/msgsigner/#pubtools.sign.signers.msgsigner.MsgBatchSigner","title":"<code>MsgBatchSigner</code>  <code>dataclass</code>","text":"<p>               Bases: <code>MsgSigner</code></p> <p>Messaging batch signer class.</p> Source code in <code>pubtools/sign/signers/msgsigner.py</code> <pre><code>class MsgBatchSigner(MsgSigner):\n    \"\"\"Messaging batch signer class.\"\"\"\n\n    _signer_config_key: str = \"msg_batch_signer\"\n\n    chunk_size: int = field(\n        init=False,\n        metadata={\n            \"description\": \"Identify how many signing claims should be send in one message\",\n            \"sample\": 10,\n        },\n    )\n\n    SUPPORTED_OPERATIONS: ClassVar[List[Type[SignOperation]]] = [\n        ContainerSignOperation,\n    ]\n\n    def _construct_signing_batch_message(\n        self: Self,\n        claims: List[str],\n        signing_keys: List[str],\n        repo: str,\n        signing_key_names: List[str] = [],\n        extra_attrs: Optional[Dict[str, Any]] = None,\n        sig_type: str = SignRequestType.CONTAINER,\n    ) -&gt; dict[str, Any]:\n        data_attr = \"claims\" if sig_type == SignRequestType.CONTAINER else \"data\"\n        _extra_attrs = extra_attrs or {}\n        processed_claims = [\n            {\n                \"claim_file\": claim,\n                \"sig_keynames\": signing_key_names,\n                \"sig_keyids\": [sig_key[-8:] for sig_key in signing_keys],\n                \"manifest_digest\": digest,\n            }\n            for claim, digest in zip(claims, _extra_attrs.get(\"manifest_digest\", \"\"))\n        ]\n        message = {\n            data_attr: processed_claims,\n            \"request_id\": str(uuid.uuid4()),\n            \"created\": isodate_now(),\n            \"requested_by\": self.creator,\n        }\n        _extra_attrs.pop(\"manifest_digest\", None)\n        message.update(_extra_attrs)\n        return message\n\n    def _create_msg_batch_message(\n        self: Self,\n        data: List[str],\n        repo: str,\n        operation: SignOperation,\n        sig_type: SignRequestType,\n        extra_attrs: Optional[Dict[str, Any]] = None,\n    ) -&gt; List[MsgMessage]:\n        messages = []\n        signing_keys = []\n        for _signing_key in operation.signing_keys:\n            if _signing_key in self.key_aliases:\n                signing_keys.append(self.key_aliases[_signing_key])\n                LOG.info(\n                    f\"Using signing key alias {self.key_aliases[_signing_key]} for {_signing_key}\"\n                )\n            else:\n                signing_keys.append(_signing_key)\n\n        extra_attrs = extra_attrs or {}\n        headers = self._construct_headers(sig_type, extra_attrs=extra_attrs)\n        if isinstance(operation, ContainerSignOperation):\n            extra_attrs[\"manifest_digest\"] = operation.digests\n        ret = MsgMessage(\n            headers=headers,\n            body=self._construct_signing_batch_message(\n                data,\n                signing_keys,\n                repo,\n                signing_key_names=(\n                    operation.signing_key_names\n                    if operation.signing_key_names\n                    else [\"\" * len(signing_keys)]\n                ),\n                extra_attrs=extra_attrs,\n                sig_type=sig_type.value,\n            ),\n            address=self.topic_send_to.format(\n                **dict(list(asdict(self).items()) + list(asdict(operation).items()))\n            ),\n        )\n        LOG.debug(f\"Construted message with request_id {ret.body['request_id']}\")\n        messages.append(ret)\n        return messages\n\n    def _prepare_messages(self: Self, operation: ContainerSignOperation) -&gt; List[List[MsgMessage]]:\n        messages: List[List[MsgMessage]] = []\n        repo_groups: Dict[str, Dict[str, List[str]]] = {}\n        for digest, reference in zip(operation.digests, operation.references):\n            repo = reference.split(\"/\", 1)[1].split(\":\")[0]\n            if repo not in repo_groups:\n                repo_groups[repo] = cast(dict[str, list[str]], {\"digests\": [], \"references\": []})\n            repo_groups[repo][\"digests\"].append(digest)\n            repo_groups[repo][\"references\"].append(reference)\n\n        batch_data: List[FData] = []\n        for repo, group in repo_groups.items():\n            claims = []\n            digests = []\n\n            for digest, reference in zip(group[\"digests\"], group[\"references\"]):\n                claims.append(\n                    self.create_manifest_claim_message(digest=digest, reference=reference)\n                )\n                digests.append(digest)\n                if len(claims) &gt;= self.chunk_size:\n                    fdata = FData(\n                        args=[claims, repo, operation, SignRequestType.CONTAINER],\n                        kwargs={\n                            \"extra_attrs\": {\n                                \"pub_task_id\": operation.task_id,\n                                \"manifest_digest\": digests,\n                            }\n                        },\n                    )\n                    batch_data.append(fdata)\n                    claims = []\n                    digests = []\n            if claims:\n                fdata = FData(\n                    args=[claims, repo, operation, SignRequestType.CONTAINER],\n                    kwargs={\n                        \"extra_attrs\": {\n                            \"pub_task_id\": operation.task_id,\n                            \"manifest_digest\": digests,\n                        }\n                    },\n                )\n                batch_data.append(fdata)\n\n            ret = run_in_parallel(self._create_msg_batch_message, batch_data)\n            messages.extend(list(ret.values()))\n        return messages\n\n    def load_config(self: Self, config_data: Dict[str, Any]) -&gt; None:\n        \"\"\"Load configuration of messaging signer.\n\n        Arguments:\n            config_data (dict): configuration data to load\n        \"\"\"\n        self.messaging_brokers = config_data[\"msg_batch_signer\"][\"messaging_brokers\"]\n        self.messaging_cert_key = os.path.expanduser(\n            config_data[\"msg_batch_signer\"][\"messaging_cert_key\"]\n        )\n        self.messaging_ca_cert = os.path.expanduser(\n            config_data[\"msg_batch_signer\"][\"messaging_ca_cert\"]\n        )\n        self.topic_send_to = config_data[\"msg_batch_signer\"][\"topic_send_to\"]\n        self.topic_listen_to = config_data[\"msg_batch_signer\"][\"topic_listen_to\"]\n        self.environment = config_data[\"msg_batch_signer\"][\"environment\"]\n        self.service = config_data[\"msg_batch_signer\"][\"service\"]\n        self.message_id_key = config_data[\"msg_batch_signer\"][\"message_id_key\"]\n        self.retries = config_data[\"msg_batch_signer\"][\"retries\"]\n        self.send_retries = config_data[\"msg_batch_signer\"][\"send_retries\"]\n        self.log_level = config_data[\"msg_batch_signer\"][\"log_level\"]\n        self.timeout = config_data[\"msg_batch_signer\"][\"timeout\"]\n        self.creator = self._get_cert_subject_cn()\n        self.key_aliases = config_data[\"msg_batch_signer\"].get(\"key_aliases\", {})\n        self.chunk_size = config_data[\"msg_batch_signer\"][\"chunk_size\"]\n</code></pre>"},{"location":"developer/api/signers/msgsigner/#pubtools.sign.signers.msgsigner.MsgBatchSigner.load_config","title":"<code>load_config(config_data)</code>","text":"<p>Load configuration of messaging signer.</p> <p>Parameters:</p> Name Type Description Default <code>config_data</code> <code>dict</code> <p>configuration data to load</p> required Source code in <code>pubtools/sign/signers/msgsigner.py</code> <pre><code>def load_config(self: Self, config_data: Dict[str, Any]) -&gt; None:\n    \"\"\"Load configuration of messaging signer.\n\n    Arguments:\n        config_data (dict): configuration data to load\n    \"\"\"\n    self.messaging_brokers = config_data[\"msg_batch_signer\"][\"messaging_brokers\"]\n    self.messaging_cert_key = os.path.expanduser(\n        config_data[\"msg_batch_signer\"][\"messaging_cert_key\"]\n    )\n    self.messaging_ca_cert = os.path.expanduser(\n        config_data[\"msg_batch_signer\"][\"messaging_ca_cert\"]\n    )\n    self.topic_send_to = config_data[\"msg_batch_signer\"][\"topic_send_to\"]\n    self.topic_listen_to = config_data[\"msg_batch_signer\"][\"topic_listen_to\"]\n    self.environment = config_data[\"msg_batch_signer\"][\"environment\"]\n    self.service = config_data[\"msg_batch_signer\"][\"service\"]\n    self.message_id_key = config_data[\"msg_batch_signer\"][\"message_id_key\"]\n    self.retries = config_data[\"msg_batch_signer\"][\"retries\"]\n    self.send_retries = config_data[\"msg_batch_signer\"][\"send_retries\"]\n    self.log_level = config_data[\"msg_batch_signer\"][\"log_level\"]\n    self.timeout = config_data[\"msg_batch_signer\"][\"timeout\"]\n    self.creator = self._get_cert_subject_cn()\n    self.key_aliases = config_data[\"msg_batch_signer\"].get(\"key_aliases\", {})\n    self.chunk_size = config_data[\"msg_batch_signer\"][\"chunk_size\"]\n</code></pre>"},{"location":"developer/api/signers/msgsigner/#pubtools.sign.signers.msgsigner.MsgSigner","title":"<code>MsgSigner</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Signer</code></p> <p>Messaging signer class.</p> Source code in <code>pubtools/sign/signers/msgsigner.py</code> <pre><code>@dataclass()\nclass MsgSigner(Signer):\n    \"\"\"Messaging signer class.\"\"\"\n\n    messaging_brokers: List[str] = field(\n        init=False,\n        metadata={\n            \"description\": \"List of brokers URLS\",\n            \"sample\": [\n                \"amqps://broker-01:5671\",\n                \"amqps://broker-02:5671\",\n            ],\n        },\n    )\n    messaging_cert_key: str = field(\n        init=False,\n        metadata={\n            \"description\": \"Client certificate + key for messaging authorization\",\n            \"sample\": \"~/messaging/cert.pem\",\n        },\n    )\n    messaging_ca_cert: str = field(\n        init=False,\n        metadata={\"description\": \"Messaging CA certificate\", \"sample\": \"~/messaging/ca_cert.crt\"},\n    )\n    topic_send_to: str = field(\n        init=False,\n        metadata={\n            \"description\": \"Topic where to send the messages\",\n            \"sample\": \"topic://Topic.sign\",\n        },\n    )\n    topic_listen_to: str = field(\n        init=False,\n        metadata={\n            \"description\": \"Topic where to listen for replies\",\n            \"sample\": \"queue://Consumer.{{creator}}.{{task_id}}.Topic.sign.{{task_id}}\",\n        },\n    )\n    creator: str = field(\n        init=False,\n        metadata={\n            \"description\": \"Identification of creator of signing request\",\n            \"sample\": \"pubtools-sign\",\n        },\n    )\n    environment: str = field(\n        init=False,\n        metadata={\"description\": \"Environment indetification in sent messages\", \"sample\": \"prod\"},\n    )\n    service: str = field(\n        init=False, metadata={\"description\": \"Service identificator\", \"sample\": \"pubtools-sign\"}\n    )\n    timeout: int = field(\n        init=False,\n        default=60,\n        metadata={\"description\": \"Timeout for messaging receive\", \"sample\": 1},\n    )\n    retries: int = field(\n        init=False,\n        default=3,\n        metadata={\"description\": \"Retries for messaging receive\", \"sample\": 3},\n    )\n    send_retries: int = field(\n        init=False,\n        default=2,\n        metadata={\"description\": \"Retries for messaging send+receive\", \"sample\": 2},\n    )\n    message_id_key: str = field(\n        init=False,\n        metadata={\n            \"description\": \"Attribute name in message body which should be used as message id\",\n            \"sample\": \"123\",\n        },\n    )\n    key_aliases: Dict[str, str] = field(\n        init=False,\n        metadata={\n            \"description\": \"Aliases for signing keys\",\n            \"sample\": \"{'production':'abcde1245'}\",\n        },\n        default_factory=dict,\n    )\n\n    log_level: str = field(init=False, metadata={\"description\": \"Log level\", \"sample\": \"debug\"})\n\n    SUPPORTED_OPERATIONS: ClassVar[List[Type[SignOperation]]] = [\n        ContainerSignOperation,\n        ClearSignOperation,\n        BlobSignOperation,\n    ]\n\n    _signer_config_key: str = \"msg_signer\"\n\n    def _construct_signing_message(\n        self: MsgSigner,\n        claim: str,\n        signing_key: str,\n        repo: str,\n        signing_key_name: str = \"\",\n        extra_attrs: Optional[Dict[str, Any]] = None,\n        sig_type: SignRequestType = SignRequestType.CONTAINER,\n    ) -&gt; dict[str, Any]:\n        if sig_type == SignRequestType.CONTAINER:\n            data_attr = \"claim_file\"\n        elif sig_type == SignRequestType.GPGSIGN:\n            data_attr = \"artifact\"\n        else:\n            data_attr = \"data\"\n        _extra_attrs = extra_attrs or {}\n        message = {\n            \"sig_key_id\": signing_key[-8:],\n            data_attr: claim,\n            \"request_id\": str(uuid.uuid4()),\n            \"created\": isodate_now(),\n            \"requested_by\": self.creator,\n            \"repo\": repo,\n        }\n        if signing_key_name:\n            message[\"sig_keyname\"] = signing_key_name\n        message.update(_extra_attrs)\n        return message\n\n    def _construct_headers(\n        self: MsgSigner, sig_type: SignRequestType, extra_attrs: Optional[Dict[str, Any]] = None\n    ) -&gt; Dict[str, Any]:\n        headers = {\n            \"service\": self.service,\n            \"environment\": self.environment,\n            \"owner_id\": self.creator,\n            \"mtype\": sig_type.value,\n            \"source\": \"metadata\",\n        }\n        if extra_attrs:\n            headers.update(extra_attrs)\n        return headers\n\n    def _create_msg_messages(\n        self: MsgSigner,\n        data: str,\n        repo: str,\n        operation: SignOperation,\n        sig_type: SignRequestType,\n        extra_attrs: Optional[Dict[str, Any]] = None,\n    ) -&gt; List[MsgMessage]:\n        messages = []\n        for _signing_key, _signing_key_name in zip(\n            operation.signing_keys,\n            operation.signing_key_names or [\"\"] * len(operation.signing_keys),\n        ):\n            if _signing_key in self.key_aliases:\n                signing_key = self.key_aliases[_signing_key]\n                LOG.info(f\"Using signing key alias {signing_key} for {_signing_key}\")\n            else:\n                signing_key = _signing_key\n            ret = MsgMessage(\n                headers=self._construct_headers(sig_type, extra_attrs=extra_attrs),\n                body=self._construct_signing_message(\n                    data,\n                    signing_key,\n                    repo,\n                    signing_key_name=_signing_key_name,\n                    extra_attrs=extra_attrs,\n                    sig_type=sig_type,\n                ),\n                address=self.topic_send_to.format(\n                    **dict(list(asdict(self).items()) + list(asdict(operation).items()))\n                ),\n            )\n            LOG.debug(f\"Construted message with request_id {ret.body['request_id']}\")\n            messages.append(ret)\n        return messages\n\n    def load_config(self: MsgSigner, config_data: Dict[str, Any]) -&gt; None:\n        \"\"\"Load configuration of messaging signer.\n\n        Arguments:\n            config_data (dict): configuration data to load\n        \"\"\"\n        self.messaging_brokers = config_data[\"msg_signer\"][\"messaging_brokers\"]\n        self.messaging_cert_key = os.path.expanduser(\n            config_data[\"msg_signer\"][\"messaging_cert_key\"]\n        )\n        self.messaging_ca_cert = os.path.expanduser(config_data[\"msg_signer\"][\"messaging_ca_cert\"])\n        self.topic_send_to = config_data[\"msg_signer\"][\"topic_send_to\"]\n        self.topic_listen_to = config_data[\"msg_signer\"][\"topic_listen_to\"]\n        self.environment = config_data[\"msg_signer\"][\"environment\"]\n        self.service = config_data[\"msg_signer\"][\"service\"]\n        self.message_id_key = config_data[\"msg_signer\"][\"message_id_key\"]\n        self.retries = config_data[\"msg_signer\"][\"retries\"]\n        self.send_retries = config_data[\"msg_signer\"][\"send_retries\"]\n        self.log_level = config_data[\"msg_signer\"][\"log_level\"]\n        self.timeout = config_data[\"msg_signer\"][\"timeout\"]\n        self.creator = self._get_cert_subject_cn()\n        self.key_aliases = config_data[\"msg_signer\"].get(\"key_aliases\", {})\n\n    def _get_cert_subject_cn(self) -&gt; str:\n        x509 = crypto.load_certificate(\n            crypto.FILETYPE_PEM, open(os.path.expanduser(self.messaging_cert_key)).read().encode()\n        )\n        return x509.get_subject().CN or x509.get_subject().UID  # type: ignore[attr-defined]\n\n    def operations(self: MsgSigner) -&gt; List[Type[SignOperation]]:\n        \"\"\"Return list of supported signing operation classes.\n\n        Returns:\n            List[Type[SignOperation]]: list of supported operations\n        \"\"\"\n        return self.SUPPORTED_OPERATIONS\n\n    def sign(self: MsgSigner, operation: SignOperation) -&gt; SigningResults:\n        \"\"\"Run signing operation.\n\n        Args:\n            operation (SignOperation): signing operation\n\n        Returns:\n            SigningResults: results of the signing operation\n        \"\"\"\n        if isinstance(operation, ClearSignOperation):\n            return self.clear_sign(operation)\n        elif isinstance(operation, ContainerSignOperation):\n            return self.container_sign(operation)\n        elif isinstance(operation, BlobSignOperation):\n            return self.blob_sign(operation)\n        else:\n            raise UnsupportedOperation(operation)\n\n    def _send_and_receive(\n        self, messages: List[Any], operation: SignOperation\n    ) -&gt; Tuple[Dict[int, Any], List[MsgError], int]:\n        received: Dict[int, Any] = {}\n        errors: List[MsgError] = []\n\n        for i in range(self.send_retries):\n            message_ids = [message.body[\"request_id\"] for message in messages]\n            LOG.debug(f\"{len(messages)} messages to send\")\n            recvc = RecvClient(\n                uid=str(i),\n                message_ids=message_ids,\n                topic=self.topic_listen_to.format(\n                    **dict(list(asdict(self).items()) + list(asdict(operation).items()))\n                ),\n                id_key=self.message_id_key,\n                broker_urls=self.messaging_brokers,\n                cert=self.messaging_cert_key,\n                ca_cert=self.messaging_ca_cert,\n                timeout=self.timeout,\n                retries=self.retries,\n                errors=errors,\n                received=received,\n            )\n            recvt = RecvThread(recvc)\n            recvt.start()\n\n            errors = SendClient(\n                messages=messages,\n                broker_urls=self.messaging_brokers,\n                cert=self.messaging_cert_key,\n                ca_cert=self.messaging_ca_cert,\n                retries=self.retries,\n                errors=errors,\n            ).run()\n            # check sender errors\n            if errors:\n                # signer_results.status = \"error\"\n                # for error in errors:\n                #     signer_results.error_message += f\"{error.name} : {error.description}\\n\"\n                return received, errors, 1\n\n            # wait for receiver to finish\n            recvt.join()\n            recvt.stop()\n\n            # check receiver errors\n            for x in range(self.retries - 1):\n                errors = recvc.get_errors()\n                if errors and errors[0].name == \"MessagingTimeout\":\n                    LOG.info(\"RETRYING %s\", x)\n                    _messages = []\n                    for message in messages:\n                        if message.body[\"request_id\"] not in received:\n                            _messages.append(message)\n                    if x != self.retries - 1:\n                        errors.pop(0)\n                    messages = _messages\n                    message_ids = [message.body[\"request_id\"] for message in messages]\n\n                    LOG.info(\"Retrying recv\")\n                    recvc = RecvClient(\n                        uid=str(i) + \"-\" + str(x),\n                        message_ids=message_ids,\n                        topic=self.topic_listen_to.format(\n                            **dict(list(asdict(self).items()) + list(asdict(operation).items()))\n                        ),\n                        id_key=self.message_id_key,\n                        broker_urls=self.messaging_brokers,\n                        cert=self.messaging_cert_key,\n                        ca_cert=self.messaging_ca_cert,\n                        timeout=self.timeout,\n                        retries=self.retries,\n                        errors=errors,\n                        received=received,\n                    )\n                    recvt = RecvThread(recvc)\n                    recvt.start()\n                    recvt.join()\n                elif not errors:\n                    break\n        return recvc.recv, recvc.get_errors(), 0 if not recvc.get_errors() else 1\n\n    def clear_sign(self: MsgSigner, operation: ClearSignOperation) -&gt; SigningResults:\n        \"\"\"Run the clearsign operation.\n\n        Args:\n            operation (ClearSignOperation): signing operation\n\n        Returns:\n            SigningResults: results of the signing operation\n        \"\"\"\n        set_log_level(LOG, self.log_level)\n        messages = []\n        message_to_data = {}\n        for in_data in operation.inputs:\n            _key_messages = self._create_msg_messages(\n                base64.b64encode(in_data.encode(\"latin1\")).decode(\"latin-1\"),\n                operation.repo,\n                operation,\n                SignRequestType.CLEARSIGN,\n                extra_attrs={\"pub_task_id\": operation.task_id},\n            )\n            for message in _key_messages:\n                message_to_data[message.body[\"request_id\"]] = message\n                messages.append(message)\n\n        all_messages = [x for x in messages]\n\n        signer_results = MsgSignerResults(status=\"ok\", error_message=\"\")\n        operation_result = ClearSignResult(\n            signing_keys=operation.signing_keys, outputs=[\"\"] * len(operation.inputs)\n        )\n        signing_results = SigningResults(\n            signer=self,\n            operation=operation,\n            signer_results=signer_results,\n            operation_result=operation_result,\n        )\n        errors: List[MsgError] = []\n        received: Dict[int, Any] = {}\n        # LOG.info(\"errors \" + str(errors))\n\n        received, errors, retcode = self._send_and_receive(messages, operation)\n\n        if errors and retcode != 0:\n            signer_results.status = \"error\"\n            for error in errors:\n                signer_results.error_message += f\"{error.name} : {error.description}\\n\"\n            return signing_results\n\n        operation_result = ClearSignResult(\n            signing_keys=operation.signing_keys, outputs=[\"\"] * len(all_messages)\n        )\n\n        for recv_id, _received in received.items():\n            operation_result.outputs[all_messages.index(message_to_data[recv_id])] = _received\n        signing_results.operation_result = operation_result\n        return signing_results\n\n    @staticmethod\n    def create_manifest_claim_message(digest: str, reference: str) -&gt; str:\n        \"\"\"Create manifest claim for container signing.\n\n        See below for the specification for the manifest claim that is created here\n        https://github.com/containers/image/blob/main/docs/containers-signature.5.md#json-data-format\n\n        Arguments:\n            digest (str): The digest of the container image manifest.\n            reference (str): The reference of the container image.\n\n        Returns:\n            str: The base64 encoded manifest claim.\n        \"\"\"\n        manifest_claim = {\n            \"critical\": {\n                \"type\": \"atomic container signature\",\n                \"image\": {\"docker-manifest-digest\": digest},\n                \"identity\": {\"docker-reference\": reference},\n            },\n            \"optional\": {\"creator\": \"pubtools-sign\"},\n        }\n        return base64.b64encode(json.dumps(manifest_claim).encode(\"latin1\")).decode(\"latin1\")\n\n    def _prepare_messages(self, operation: ContainerSignOperation) -&gt; List[List[MsgMessage]]:\n        fargs = []\n        for digest, reference in zip(operation.digests, operation.references):\n            repo = reference.split(\"/\", 1)[1].split(\":\")[0]\n            fargs.append(\n                FData(\n                    args=[\n                        self.create_manifest_claim_message(digest=digest, reference=reference),\n                        repo,\n                        operation,\n                        SignRequestType.CONTAINER,\n                    ],\n                    kwargs={\n                        \"extra_attrs\": {\"pub_task_id\": operation.task_id, \"manifest_digest\": digest}\n                    },\n                )\n            )\n        ret = run_in_parallel(self._create_msg_messages, fargs)\n        return list(ret.values())\n\n    def container_sign(self: MsgSigner, operation: ContainerSignOperation) -&gt; SigningResults:\n        \"\"\"Run container signing operation.\n\n        Arguments:\n            operation (ContainerSignOperation): signing operation\n\n        Results:\n            SigningResults: results of the signing operation\n        \"\"\"\n        set_log_level(LOG, self.log_level)\n        messages = []\n        message_to_data = {}\n        if len(operation.digests) != len(operation.references):\n            raise ValueError(\"Digests must pairs with references\")\n\n        signer_results = MsgSignerResults(status=\"ok\", error_message=\"\")\n        operation_result = ContainerSignResult(\n            signing_keys=operation.signing_keys, results=[\"\"] * len(operation.digests), failed=False\n        )\n        signing_results = SigningResults(\n            signer=self,\n            operation=operation,\n            signer_results=signer_results,\n            operation_result=operation_result,\n        )\n\n        LOG.info(f\"Container sign operation for {len(operation.digests)}\")\n\n        ret = self._prepare_messages(operation)\n\n        for _key_messages in ret:\n            for message in _key_messages:\n                message_to_data[message.body[\"request_id\"]] = message\n                messages.append(message)\n\n        all_messages = [x for x in messages]\n        operation_result = ContainerSignResult(\n            signing_keys=operation.signing_keys, results=[\"\"] * len(all_messages), failed=False\n        )\n\n        LOG.info(f\"Signing {len(all_messages)} requests\")\n\n        LOG.debug(f\"{len(messages)} messages to send\")\n\n        errors: List[MsgError] = []\n        received: Dict[int, Any] = {}\n        LOG.info(\n            \"Starting signing process. Retries (send: %d, recv:%d), timeout: %d\",\n            self.send_retries,\n            self.retries,\n            self.timeout,\n        )\n\n        received, errors, retcode = self._send_and_receive(messages, operation)\n\n        if errors and retcode != 0:\n            signer_results.status = \"error\"\n            for error in errors:\n                signer_results.error_message += f\"{error.name} : {error.description}\\n\"\n            return signing_results\n\n        for recv_id, _received in received.items():\n            operation_result.failed = True if _received[0][\"msg\"][\"errors\"] else False\n            operation_result.results[all_messages.index(message_to_data[recv_id])] = _received\n\n        signing_results.operation_result = operation_result\n        return signing_results\n\n    def blob_sign(self: MsgSigner, operation: BlobSignOperation) -&gt; SigningResults:\n        \"\"\"Run blob signing operation.\n\n        Arguments:\n            operation (BlobSignOperation): signing operation\n\n        Results:\n            SigningResults: results of the signing operation\n        \"\"\"\n        set_log_level(LOG, self.log_level)\n        messages = []\n        message_to_data = {}\n        for blob in operation.blobs:\n            _key_messages = self._create_msg_messages(\n                blob,\n                \"\",\n                operation,\n                SignRequestType.GPGSIGN,\n                extra_attrs={\"pub_task_id\": operation.task_id, \"manifest_digest\": \"\"},\n            )\n            for message in _key_messages:\n                message_to_data[message.body[\"request_id\"]] = message\n                messages.append(message)\n\n        all_messages = [x for x in messages]\n\n        signer_results = MsgSignerResults(status=\"ok\", error_message=\"\")\n        operation_result = BlobSignResult(\n            signing_keys=operation.signing_keys, results=[\"\"] * len(all_messages), failed=False\n        )\n        signing_results = SigningResults(\n            signer=self,\n            operation=operation,\n            signer_results=signer_results,\n            operation_result=operation_result,\n        )\n        errors: List[MsgError] = []\n        received: Dict[int, Any] = {}\n        # LOG.info(\"errors \" + str(errors))\n\n        received, errors, retcode = self._send_and_receive(messages, operation)\n\n        if errors and retcode != 0:\n            signer_results.status = \"error\"\n            for error in errors:\n                signer_results.error_message += f\"{error.name} : {error.description}\\n\"\n            return signing_results\n\n        for recv_id, _received in received.items():\n            operation_result.failed = True if _received[0][\"msg\"][\"errors\"] else False\n            operation_result.results[all_messages.index(message_to_data[recv_id])] = _received\n\n        signing_results.operation_result = operation_result\n        return signing_results\n</code></pre>"},{"location":"developer/api/signers/msgsigner/#pubtools.sign.signers.msgsigner.MsgSigner.blob_sign","title":"<code>blob_sign(operation)</code>","text":"<p>Run blob signing operation.</p> <p>Parameters:</p> Name Type Description Default <code>operation</code> <code>BlobSignOperation</code> <p>signing operation</p> required Results <p>SigningResults: results of the signing operation</p> Source code in <code>pubtools/sign/signers/msgsigner.py</code> <pre><code>def blob_sign(self: MsgSigner, operation: BlobSignOperation) -&gt; SigningResults:\n    \"\"\"Run blob signing operation.\n\n    Arguments:\n        operation (BlobSignOperation): signing operation\n\n    Results:\n        SigningResults: results of the signing operation\n    \"\"\"\n    set_log_level(LOG, self.log_level)\n    messages = []\n    message_to_data = {}\n    for blob in operation.blobs:\n        _key_messages = self._create_msg_messages(\n            blob,\n            \"\",\n            operation,\n            SignRequestType.GPGSIGN,\n            extra_attrs={\"pub_task_id\": operation.task_id, \"manifest_digest\": \"\"},\n        )\n        for message in _key_messages:\n            message_to_data[message.body[\"request_id\"]] = message\n            messages.append(message)\n\n    all_messages = [x for x in messages]\n\n    signer_results = MsgSignerResults(status=\"ok\", error_message=\"\")\n    operation_result = BlobSignResult(\n        signing_keys=operation.signing_keys, results=[\"\"] * len(all_messages), failed=False\n    )\n    signing_results = SigningResults(\n        signer=self,\n        operation=operation,\n        signer_results=signer_results,\n        operation_result=operation_result,\n    )\n    errors: List[MsgError] = []\n    received: Dict[int, Any] = {}\n    # LOG.info(\"errors \" + str(errors))\n\n    received, errors, retcode = self._send_and_receive(messages, operation)\n\n    if errors and retcode != 0:\n        signer_results.status = \"error\"\n        for error in errors:\n            signer_results.error_message += f\"{error.name} : {error.description}\\n\"\n        return signing_results\n\n    for recv_id, _received in received.items():\n        operation_result.failed = True if _received[0][\"msg\"][\"errors\"] else False\n        operation_result.results[all_messages.index(message_to_data[recv_id])] = _received\n\n    signing_results.operation_result = operation_result\n    return signing_results\n</code></pre>"},{"location":"developer/api/signers/msgsigner/#pubtools.sign.signers.msgsigner.MsgSigner.clear_sign","title":"<code>clear_sign(operation)</code>","text":"<p>Run the clearsign operation.</p> <p>Parameters:</p> Name Type Description Default <code>operation</code> <code>ClearSignOperation</code> <p>signing operation</p> required <p>Returns:</p> Name Type Description <code>SigningResults</code> <code>SigningResults</code> <p>results of the signing operation</p> Source code in <code>pubtools/sign/signers/msgsigner.py</code> <pre><code>def clear_sign(self: MsgSigner, operation: ClearSignOperation) -&gt; SigningResults:\n    \"\"\"Run the clearsign operation.\n\n    Args:\n        operation (ClearSignOperation): signing operation\n\n    Returns:\n        SigningResults: results of the signing operation\n    \"\"\"\n    set_log_level(LOG, self.log_level)\n    messages = []\n    message_to_data = {}\n    for in_data in operation.inputs:\n        _key_messages = self._create_msg_messages(\n            base64.b64encode(in_data.encode(\"latin1\")).decode(\"latin-1\"),\n            operation.repo,\n            operation,\n            SignRequestType.CLEARSIGN,\n            extra_attrs={\"pub_task_id\": operation.task_id},\n        )\n        for message in _key_messages:\n            message_to_data[message.body[\"request_id\"]] = message\n            messages.append(message)\n\n    all_messages = [x for x in messages]\n\n    signer_results = MsgSignerResults(status=\"ok\", error_message=\"\")\n    operation_result = ClearSignResult(\n        signing_keys=operation.signing_keys, outputs=[\"\"] * len(operation.inputs)\n    )\n    signing_results = SigningResults(\n        signer=self,\n        operation=operation,\n        signer_results=signer_results,\n        operation_result=operation_result,\n    )\n    errors: List[MsgError] = []\n    received: Dict[int, Any] = {}\n    # LOG.info(\"errors \" + str(errors))\n\n    received, errors, retcode = self._send_and_receive(messages, operation)\n\n    if errors and retcode != 0:\n        signer_results.status = \"error\"\n        for error in errors:\n            signer_results.error_message += f\"{error.name} : {error.description}\\n\"\n        return signing_results\n\n    operation_result = ClearSignResult(\n        signing_keys=operation.signing_keys, outputs=[\"\"] * len(all_messages)\n    )\n\n    for recv_id, _received in received.items():\n        operation_result.outputs[all_messages.index(message_to_data[recv_id])] = _received\n    signing_results.operation_result = operation_result\n    return signing_results\n</code></pre>"},{"location":"developer/api/signers/msgsigner/#pubtools.sign.signers.msgsigner.MsgSigner.container_sign","title":"<code>container_sign(operation)</code>","text":"<p>Run container signing operation.</p> <p>Parameters:</p> Name Type Description Default <code>operation</code> <code>ContainerSignOperation</code> <p>signing operation</p> required Results <p>SigningResults: results of the signing operation</p> Source code in <code>pubtools/sign/signers/msgsigner.py</code> <pre><code>def container_sign(self: MsgSigner, operation: ContainerSignOperation) -&gt; SigningResults:\n    \"\"\"Run container signing operation.\n\n    Arguments:\n        operation (ContainerSignOperation): signing operation\n\n    Results:\n        SigningResults: results of the signing operation\n    \"\"\"\n    set_log_level(LOG, self.log_level)\n    messages = []\n    message_to_data = {}\n    if len(operation.digests) != len(operation.references):\n        raise ValueError(\"Digests must pairs with references\")\n\n    signer_results = MsgSignerResults(status=\"ok\", error_message=\"\")\n    operation_result = ContainerSignResult(\n        signing_keys=operation.signing_keys, results=[\"\"] * len(operation.digests), failed=False\n    )\n    signing_results = SigningResults(\n        signer=self,\n        operation=operation,\n        signer_results=signer_results,\n        operation_result=operation_result,\n    )\n\n    LOG.info(f\"Container sign operation for {len(operation.digests)}\")\n\n    ret = self._prepare_messages(operation)\n\n    for _key_messages in ret:\n        for message in _key_messages:\n            message_to_data[message.body[\"request_id\"]] = message\n            messages.append(message)\n\n    all_messages = [x for x in messages]\n    operation_result = ContainerSignResult(\n        signing_keys=operation.signing_keys, results=[\"\"] * len(all_messages), failed=False\n    )\n\n    LOG.info(f\"Signing {len(all_messages)} requests\")\n\n    LOG.debug(f\"{len(messages)} messages to send\")\n\n    errors: List[MsgError] = []\n    received: Dict[int, Any] = {}\n    LOG.info(\n        \"Starting signing process. Retries (send: %d, recv:%d), timeout: %d\",\n        self.send_retries,\n        self.retries,\n        self.timeout,\n    )\n\n    received, errors, retcode = self._send_and_receive(messages, operation)\n\n    if errors and retcode != 0:\n        signer_results.status = \"error\"\n        for error in errors:\n            signer_results.error_message += f\"{error.name} : {error.description}\\n\"\n        return signing_results\n\n    for recv_id, _received in received.items():\n        operation_result.failed = True if _received[0][\"msg\"][\"errors\"] else False\n        operation_result.results[all_messages.index(message_to_data[recv_id])] = _received\n\n    signing_results.operation_result = operation_result\n    return signing_results\n</code></pre>"},{"location":"developer/api/signers/msgsigner/#pubtools.sign.signers.msgsigner.MsgSigner.create_manifest_claim_message","title":"<code>create_manifest_claim_message(digest, reference)</code>  <code>staticmethod</code>","text":"<p>Create manifest claim for container signing.</p> <p>See below for the specification for the manifest claim that is created here https://github.com/containers/image/blob/main/docs/containers-signature.5.md#json-data-format</p> <p>Parameters:</p> Name Type Description Default <code>digest</code> <code>str</code> <p>The digest of the container image manifest.</p> required <code>reference</code> <code>str</code> <p>The reference of the container image.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The base64 encoded manifest claim.</p> Source code in <code>pubtools/sign/signers/msgsigner.py</code> <pre><code>@staticmethod\ndef create_manifest_claim_message(digest: str, reference: str) -&gt; str:\n    \"\"\"Create manifest claim for container signing.\n\n    See below for the specification for the manifest claim that is created here\n    https://github.com/containers/image/blob/main/docs/containers-signature.5.md#json-data-format\n\n    Arguments:\n        digest (str): The digest of the container image manifest.\n        reference (str): The reference of the container image.\n\n    Returns:\n        str: The base64 encoded manifest claim.\n    \"\"\"\n    manifest_claim = {\n        \"critical\": {\n            \"type\": \"atomic container signature\",\n            \"image\": {\"docker-manifest-digest\": digest},\n            \"identity\": {\"docker-reference\": reference},\n        },\n        \"optional\": {\"creator\": \"pubtools-sign\"},\n    }\n    return base64.b64encode(json.dumps(manifest_claim).encode(\"latin1\")).decode(\"latin1\")\n</code></pre>"},{"location":"developer/api/signers/msgsigner/#pubtools.sign.signers.msgsigner.MsgSigner.load_config","title":"<code>load_config(config_data)</code>","text":"<p>Load configuration of messaging signer.</p> <p>Parameters:</p> Name Type Description Default <code>config_data</code> <code>dict</code> <p>configuration data to load</p> required Source code in <code>pubtools/sign/signers/msgsigner.py</code> <pre><code>def load_config(self: MsgSigner, config_data: Dict[str, Any]) -&gt; None:\n    \"\"\"Load configuration of messaging signer.\n\n    Arguments:\n        config_data (dict): configuration data to load\n    \"\"\"\n    self.messaging_brokers = config_data[\"msg_signer\"][\"messaging_brokers\"]\n    self.messaging_cert_key = os.path.expanduser(\n        config_data[\"msg_signer\"][\"messaging_cert_key\"]\n    )\n    self.messaging_ca_cert = os.path.expanduser(config_data[\"msg_signer\"][\"messaging_ca_cert\"])\n    self.topic_send_to = config_data[\"msg_signer\"][\"topic_send_to\"]\n    self.topic_listen_to = config_data[\"msg_signer\"][\"topic_listen_to\"]\n    self.environment = config_data[\"msg_signer\"][\"environment\"]\n    self.service = config_data[\"msg_signer\"][\"service\"]\n    self.message_id_key = config_data[\"msg_signer\"][\"message_id_key\"]\n    self.retries = config_data[\"msg_signer\"][\"retries\"]\n    self.send_retries = config_data[\"msg_signer\"][\"send_retries\"]\n    self.log_level = config_data[\"msg_signer\"][\"log_level\"]\n    self.timeout = config_data[\"msg_signer\"][\"timeout\"]\n    self.creator = self._get_cert_subject_cn()\n    self.key_aliases = config_data[\"msg_signer\"].get(\"key_aliases\", {})\n</code></pre>"},{"location":"developer/api/signers/msgsigner/#pubtools.sign.signers.msgsigner.MsgSigner.operations","title":"<code>operations()</code>","text":"<p>Return list of supported signing operation classes.</p> <p>Returns:</p> Type Description <code>List[Type[SignOperation]]</code> <p>List[Type[SignOperation]]: list of supported operations</p> Source code in <code>pubtools/sign/signers/msgsigner.py</code> <pre><code>def operations(self: MsgSigner) -&gt; List[Type[SignOperation]]:\n    \"\"\"Return list of supported signing operation classes.\n\n    Returns:\n        List[Type[SignOperation]]: list of supported operations\n    \"\"\"\n    return self.SUPPORTED_OPERATIONS\n</code></pre>"},{"location":"developer/api/signers/msgsigner/#pubtools.sign.signers.msgsigner.MsgSigner.sign","title":"<code>sign(operation)</code>","text":"<p>Run signing operation.</p> <p>Parameters:</p> Name Type Description Default <code>operation</code> <code>SignOperation</code> <p>signing operation</p> required <p>Returns:</p> Name Type Description <code>SigningResults</code> <code>SigningResults</code> <p>results of the signing operation</p> Source code in <code>pubtools/sign/signers/msgsigner.py</code> <pre><code>def sign(self: MsgSigner, operation: SignOperation) -&gt; SigningResults:\n    \"\"\"Run signing operation.\n\n    Args:\n        operation (SignOperation): signing operation\n\n    Returns:\n        SigningResults: results of the signing operation\n    \"\"\"\n    if isinstance(operation, ClearSignOperation):\n        return self.clear_sign(operation)\n    elif isinstance(operation, ContainerSignOperation):\n        return self.container_sign(operation)\n    elif isinstance(operation, BlobSignOperation):\n        return self.blob_sign(operation)\n    else:\n        raise UnsupportedOperation(operation)\n</code></pre>"},{"location":"developer/api/signers/msgsigner/#pubtools.sign.signers.msgsigner.MsgSignerResults","title":"<code>MsgSignerResults</code>  <code>dataclass</code>","text":"<p>               Bases: <code>SignerResults</code></p> <p>MsgSignerResults model.</p> Source code in <code>pubtools/sign/signers/msgsigner.py</code> <pre><code>@dataclass()\nclass MsgSignerResults(SignerResults):\n    \"\"\"MsgSignerResults model.\"\"\"\n\n    status: str\n    error_message: str\n\n    def to_dict(self: SignerResults) -&gt; Dict[Any, Any]:\n        \"\"\"Return dict representation of MsgSignerResults model.\"\"\"\n        return {\"status\": self.status, \"error_message\": self.error_message}\n\n    @classmethod\n    def doc_arguments(cls: Type[Self]) -&gt; Dict[str, Any]:\n        \"\"\"Return dictionary with result description of SignerResults.\"\"\"\n        doc_arguments = {\n            \"signer_result\": {\n                \"type\": \"dict\",\n                \"description\": \"Signing result status.\",\n                \"returned\": \"always\",\n                \"sample\": {\"status\": \"ok\", \"error_message\": \"\"},\n            }\n        }\n\n        return doc_arguments\n</code></pre>"},{"location":"developer/api/signers/msgsigner/#pubtools.sign.signers.msgsigner.MsgSignerResults.doc_arguments","title":"<code>doc_arguments()</code>  <code>classmethod</code>","text":"<p>Return dictionary with result description of SignerResults.</p> Source code in <code>pubtools/sign/signers/msgsigner.py</code> <pre><code>@classmethod\ndef doc_arguments(cls: Type[Self]) -&gt; Dict[str, Any]:\n    \"\"\"Return dictionary with result description of SignerResults.\"\"\"\n    doc_arguments = {\n        \"signer_result\": {\n            \"type\": \"dict\",\n            \"description\": \"Signing result status.\",\n            \"returned\": \"always\",\n            \"sample\": {\"status\": \"ok\", \"error_message\": \"\"},\n        }\n    }\n\n    return doc_arguments\n</code></pre>"},{"location":"developer/api/signers/msgsigner/#pubtools.sign.signers.msgsigner.MsgSignerResults.to_dict","title":"<code>to_dict()</code>","text":"<p>Return dict representation of MsgSignerResults model.</p> Source code in <code>pubtools/sign/signers/msgsigner.py</code> <pre><code>def to_dict(self: SignerResults) -&gt; Dict[Any, Any]:\n    \"\"\"Return dict representation of MsgSignerResults model.\"\"\"\n    return {\"status\": self.status, \"error_message\": self.error_message}\n</code></pre>"},{"location":"developer/api/signers/msgsigner/#pubtools.sign.signers.msgsigner.SignRequestType","title":"<code>SignRequestType</code>","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> <p>Sign request type enum.</p> Source code in <code>pubtools/sign/signers/msgsigner.py</code> <pre><code>class SignRequestType(str, enum.Enum):\n    \"\"\"Sign request type enum.\"\"\"\n\n    CONTAINER = \"container_signature\"\n    CLEARSIGN = \"clearsign_signature\"\n    GPGSIGN = \"gpg_signature\"\n</code></pre>"},{"location":"developer/api/signers/msgsigner/#pubtools.sign.signers.msgsigner.msg_blob_sign","title":"<code>msg_blob_sign(signing_keys, signing_key_names, task_id, config_file, blob_files, requester='', signer_type='single')</code>","text":"<p>Run blobsign operation with cli arguments.</p> Source code in <code>pubtools/sign/signers/msgsigner.py</code> <pre><code>def msg_blob_sign(\n    signing_keys: List[str],\n    signing_key_names: List[str],\n    task_id: str,\n    config_file: str,\n    blob_files: List[str],\n    requester: str = \"\",\n    signer_type: str = \"single\",\n) -&gt; Dict[str, Any]:\n    \"\"\"Run blobsign operation with cli arguments.\"\"\"\n    if signer_type == \"single\":\n        msg_signer = MsgSigner()\n    elif signer_type == \"batch\":\n        raise NotImplementedError(\"Batch signer does not support blob signing yet\")\n\n    config = _get_config_file(config_file)\n    msg_signer.load_config(load_config(os.path.expanduser(config)))\n    if requester:\n        msg_signer.creator = requester\n\n    blobs = []\n    for blob_file in blob_files:\n        with open(blob_file, \"rb\") as bf:\n            blobs.append(base64.b64encode(bf.read()).decode(\"utf-8\"))\n\n    operation = BlobSignOperation(\n        blobs=blobs,\n        signing_keys=signing_keys,\n        signing_key_names=signing_key_names,\n        task_id=task_id,\n        requester=requester,\n    )\n    signing_result = msg_signer.sign(operation)\n    return {\n        \"signer_result\": signing_result.signer_results.to_dict(),\n        \"operation_results\": signing_result.operation_result.results,\n        \"operation\": signing_result.operation.to_dict(),\n        \"signing_keys\": signing_result.operation_result.signing_keys,\n    }\n</code></pre>"},{"location":"developer/api/signers/msgsigner/#pubtools.sign.signers.msgsigner.msg_blob_sign_main","title":"<code>msg_blob_sign_main(signing_key, signing_key_name, task_id='', config_file='', blob_file=[], requester='', raw=False, log_level='INFO', signer_type='single')</code>","text":"<p>Entry point method for blobsign operation.</p> <p>Print following json output on stdout when <code>--raw</code> is NOT set:</p> <p>{     \"signer_result\": pubtools.sign.signers.msgsigner.MsgSignerResults,     \"operation_results\": [pubtools.sign.results.blobsign.BlobSignResult][],     \"operation\": [pubtools.sign.operations.blobsign.BlobSignOperation][],     \"signing_keys\": [\"signing_key_id\"] }</p> <p>Otherwise prints one signed claim per line if sucessfull or error messages</p> Source code in <code>pubtools/sign/signers/msgsigner.py</code> <pre><code>@click.command()\n@click.option(\n    \"--signing-key\",\n    required=True,\n    multiple=True,\n    help=\"8 characters key fingerprint of key which should be used for signing or key alias\",\n)\n@click.option(\n    \"--signing-key-name\",\n    required=False,\n    multiple=True,\n    help=\"signing key name\",\n)\n@click.option(\"--task-id\", required=True, help=\"Task id identifier (usually pub task-id)\")\n@click.option(\"--config-file\", default=CONFIG_PATHS[0], help=\"path to the config file\")\n@click.option(\n    \"--blob-file\",\n    required=True,\n    multiple=True,\n    type=str,\n    help=\"Blob files to sign (paths to files whose contents will be signed).\",\n)\n@click.option(\n    \"--requester\",\n    required=False,\n    multiple=False,\n    type=str,\n    help=\"Use this requester instead of the one from the certificate file.\",\n)\n@click.option(\"--raw\", default=False, is_flag=True, help=\"Print raw output instead of json\")\n@click.option(\n    \"--log-level\",\n    type=click.Choice([\"DEBUG\", \"INFO\", \"WARNING\", \"ERROR\"]),\n    default=\"INFO\",\n    help=\"Set log level\",\n)\n@click.option(\n    \"--signer-type\", type=click.Choice([\"single\", \"batch\"]), default=\"single\", help=\"Signer type\"\n)\ndef msg_blob_sign_main(\n    signing_key: List[str],\n    signing_key_name: List[str],\n    task_id: str = \"\",\n    config_file: str = \"\",\n    blob_file: List[str] = [],\n    requester: str = \"\",\n    raw: bool = False,\n    log_level: str = \"INFO\",\n    signer_type: str = \"single\",\n) -&gt; None:\n    \"\"\"Entry point method for blobsign operation.\n\n    Print following json output on stdout when `--raw` is NOT set:\n\n    {\n        \"signer_result\": [pubtools.sign.signers.msgsigner.MsgSignerResults][],\n        \"operation_results\": [pubtools.sign.results.blobsign.BlobSignResult][],\n        \"operation\": [pubtools.sign.operations.blobsign.BlobSignOperation][],\n        \"signing_keys\": [\"signing_key_id\"]\n    }\n\n    Otherwise prints one signed claim per line if sucessfull or error messages\n    \"\"\"\n    ch = logging.StreamHandler()\n    ch.setLevel(getattr(logging, sanitize_log_level(log_level)))\n    LOG.addHandler(ch)\n    logging.basicConfig(level=getattr(logging, sanitize_log_level(log_level)))\n\n    ret = msg_blob_sign(\n        signing_keys=signing_key,\n        signing_key_names=signing_key_name,\n        task_id=task_id,\n        config_file=config_file,\n        blob_files=blob_file,\n        requester=requester,\n        signer_type=signer_type,\n    )\n    if not raw:\n        click.echo(json.dumps(ret))\n        if ret[\"signer_result\"][\"status\"] == \"error\":\n            sys.exit(1)\n    else:\n        if ret[\"signer_result\"][\"status\"] == \"error\":\n            print(ret[\"signer_result\"][\"error_message\"], file=sys.stderr)\n            sys.exit(1)\n        else:\n            for claim in ret[\"operation_results\"]:\n                if claim[0][\"msg\"][\"errors\"]:\n                    for error in claim[0][\"msg\"][\"errors\"]:\n                        print(error, file=sys.stderr)\n                    sys.exit(1)\n                else:\n                    print(claim[0][\"msg\"][\"signed_payload\"])\n</code></pre>"},{"location":"developer/api/signers/msgsigner/#pubtools.sign.signers.msgsigner.msg_clear_sign","title":"<code>msg_clear_sign(inputs, signing_keys=[], task_id='', config_file='', repo='', requester='')</code>","text":"<p>Run clearsign operation on provided inputs.</p> <p>Parameters:</p> Name Type Description Default <code>inputs</code> <code>List[str]</code> <p>List of input strings or file paths(when prefixed with '@') to sign.</p> required <code>signing_key</code> <code>str</code> <p>8 characters key fingerprint of key which should be used for signing.</p> required <code>task_id</code> <code>str</code> <p>Task id identifier.</p> <code>''</code> <code>config_file</code> <code>str</code> <p>Path to the pubtools-sign configuration file.</p> <code>''</code> <code>repo</code> <code>str</code> <p>Repository reference.</p> <code>''</code> <code>requester</code> <code>str</code> <p>Use this requester instead one from certificate file.</p> <code>''</code> <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>Dict[str, Any]: Dictionary containing the signing results,</p> <code>Dict[str, Any]</code> <p>operation results, operation details, and signing key.</p> Source code in <code>pubtools/sign/signers/msgsigner.py</code> <pre><code>def msg_clear_sign(\n    inputs: List[str],\n    signing_keys: List[str] = [],\n    task_id: str = \"\",\n    config_file: str = \"\",\n    repo: str = \"\",\n    requester: str = \"\",\n) -&gt; Dict[str, Any]:\n    \"\"\"Run clearsign operation on provided inputs.\n\n    Arguments:\n        inputs (List[str]): List of input strings or file paths(when prefixed with '@') to sign.\n        signing_key (str): 8 characters key fingerprint of key which should be used for signing.\n        task_id (str): Task id identifier.\n        config_file (str): Path to the pubtools-sign configuration file.\n        repo (str): Repository reference.\n        requester (str): Use this requester instead one from certificate file.\n\n    Returns:\n        Dict[str, Any]: Dictionary containing the signing results,\n        operation results, operation details, and signing key.\n    \"\"\"\n    msg_signer = MsgSigner()\n    config = _get_config_file(config_file)\n    msg_signer.load_config(load_config(os.path.expanduser(config)))\n    if requester:\n        msg_signer.creator = requester\n\n    str_inputs = []\n    for input_ in inputs:\n        if input_.startswith(\"@\"):\n            str_inputs.append(open(input_.lstrip(\"@\")).read())\n        else:\n            str_inputs.append(input_)\n    operation = ClearSignOperation(\n        inputs=str_inputs,\n        signing_keys=signing_keys,\n        task_id=task_id,\n        repo=repo,\n        requester=requester,\n    )\n    signing_result = msg_signer.sign(operation)\n    return {\n        \"signer_result\": signing_result.signer_results.to_dict(),\n        \"operation_results\": cast(ClearSignResult, signing_result.operation_result).outputs,\n        \"operation\": signing_result.operation.to_dict(),\n        \"signing_keys\": signing_result.operation_result.signing_keys,\n    }\n</code></pre>"},{"location":"developer/api/signers/msgsigner/#pubtools.sign.signers.msgsigner.msg_clear_sign_main","title":"<code>msg_clear_sign_main(inputs, signing_key=[], task_id='', config_file='', raw=False, log_level='INFO', requester='', repo='')</code>","text":"<p>Entry point method for clearsign operation.</p> <p>Print following json output on stdout if <code>--raw</code> is set:</p> <p>{     \"signer_result\": pubtools.sign.signers.msgsigner.MsgSignerResults,     \"operation_results\": pubtools.sign.results.clearsign.ClearSignResult,     \"operation\": pubtools.sign.operations.clearsign.ClearSignOperation,     \"signing_key\": \"signing_key_id\"   }</p> <p>Otherwise prints one clearsigned output per line if sucessfull or error messages if not</p> Source code in <code>pubtools/sign/signers/msgsigner.py</code> <pre><code>@click.command()\n@click.option(\n    \"--signing-key\",\n    required=True,\n    multiple=True,\n    help=\"8 characters key fingerprint of key which should be used for signing or key alias\",\n)\n@click.option(\"--task-id\", required=True, help=\"Task id identifier (usually pub task-id)\")\n@click.option(\"--config-file\", default=CONFIG_PATHS[0], help=\"path to the config file\")\n@click.option(\"--raw\", default=False, is_flag=True, help=\"Print raw output instead of json\")\n@click.option(\n    \"--log-level\",\n    type=click.Choice([\"DEBUG\", \"INFO\", \"WARNING\", \"ERROR\"]),\n    default=\"INFO\",\n    help=\"Set log level\",\n)\n@click.option(\n    \"--requester\",\n    required=False,\n    multiple=False,\n    type=str,\n    help=\"Use this requester instead one from certificate file.\",\n)\n@click.option(\"--repo\", help=\"Repository reference\")\n@click.argument(\"inputs\", nargs=-1)\ndef msg_clear_sign_main(\n    inputs: List[str],\n    signing_key: List[str] = [],\n    task_id: str = \"\",\n    config_file: str = \"\",\n    raw: bool = False,\n    log_level: str = \"INFO\",\n    requester: str = \"\",\n    repo: str = \"\",\n) -&gt; None:\n    \"\"\"Entry point method for clearsign operation.\n\n    Print following json output on stdout if `--raw` is set:\n\n    &gt;   {\n    &gt;     \"signer_result\": [pubtools.sign.signers.msgsigner.MsgSignerResults][],\n    &gt;     \"operation_results\": [pubtools.sign.results.clearsign.ClearSignResult][],\n    &gt;     \"operation\": [pubtools.sign.operations.clearsign.ClearSignOperation][],\n    &gt;     \"signing_key\": \"signing_key_id\"\n    &gt;   }\n\n    Otherwise prints one clearsigned output per line if sucessfull or error messages if not\n    \"\"\"\n    ch = logging.StreamHandler()\n    ch.setLevel(getattr(logging, sanitize_log_level(log_level)))\n\n    LOG.addHandler(ch)\n    logging.basicConfig(level=getattr(logging, sanitize_log_level(log_level)))\n\n    ret = msg_clear_sign(\n        inputs,\n        signing_keys=signing_key,\n        task_id=task_id,\n        repo=repo,\n        requester=requester,\n        config_file=config_file,\n    )\n    if not raw:\n        click.echo(json.dumps(ret))\n        if ret[\"signer_result\"][\"status\"] == \"error\":\n            sys.exit(1)\n    else:\n        if ret[\"signer_result\"][\"status\"] == \"error\":\n            print(ret[\"signer_result\"][\"error_message\"], file=sys.stderr)\n            sys.exit(1)\n        else:\n            for claim in ret[\"operation_results\"]:\n                if claim[0][\"msg\"][\"errors\"]:\n                    for error in claim[0][\"msg\"][\"errors\"]:\n                        print(error, file=sys.stderr)\n                    sys.exit(1)\n                else:\n                    print(claim[0][\"msg\"][\"signed_data\"])\n</code></pre>"},{"location":"developer/api/signers/msgsigner/#pubtools.sign.signers.msgsigner.msg_container_sign","title":"<code>msg_container_sign(signing_keys=[], signing_key_names=[], task_id='', config_file='', digest=[], reference=[], requester='', signer_type='single')</code>","text":"<p>Run containersign operation with cli arguments.</p> Source code in <code>pubtools/sign/signers/msgsigner.py</code> <pre><code>def msg_container_sign(\n    signing_keys: List[str] = [],\n    signing_key_names: List[str] = [],\n    task_id: str = \"\",\n    config_file: str = \"\",\n    digest: list[str] = [],\n    reference: list[str] = [],\n    requester: str = \"\",\n    signer_type: str = \"single\",\n) -&gt; Dict[str, Any]:\n    \"\"\"Run containersign operation with cli arguments.\"\"\"\n    if signer_type == \"single\":\n        msg_signer = MsgSigner()\n    elif signer_type == \"batch\":\n        msg_signer = MsgBatchSigner()\n\n    config = _get_config_file(config_file)\n    msg_signer.load_config(load_config(os.path.expanduser(config)))\n    if requester:\n        msg_signer.creator = requester\n\n    operation = ContainerSignOperation(\n        digests=digest,\n        references=reference,\n        signing_keys=signing_keys,\n        signing_key_names=signing_key_names,\n        task_id=task_id,\n        requester=requester,\n    )\n    signing_result = msg_signer.sign(operation)\n    return {\n        \"signer_result\": signing_result.signer_results.to_dict(),\n        \"operation_results\": signing_result.operation_result.results,\n        \"operation\": signing_result.operation.to_dict(),\n        \"signing_keys\": signing_result.operation_result.signing_keys,\n    }\n</code></pre>"},{"location":"developer/api/signers/msgsigner/#pubtools.sign.signers.msgsigner.msg_container_sign_main","title":"<code>msg_container_sign_main(signing_key=[], signing_key_name=[], task_id='', config_file='', digest=[], reference=[], requester='', raw=False, log_level='INFO', signer_type='single')</code>","text":"<p>Entry point method for containersign operation.</p> <p>Print following json output on stdout when <code>--raw</code> is set:</p> <p>{     \"signer_result\": pubtools.sign.signers.msgsigner.MsgSignerResults,     \"operation_results\": pubtools.sign.results.containersign.ContainerSignResult,     \"operation\": pubtools.sign.operations.containersign.ContainerSignOperation,     \"signing_keys\": [\"signing_key_id\"] }</p> <p>Otherwise prints one signed claim per line if sucessfull or error messages if not</p> Source code in <code>pubtools/sign/signers/msgsigner.py</code> <pre><code>@click.command()\n@click.option(\n    \"--signing-key\",\n    required=True,\n    multiple=True,\n    help=\"8 characters key fingerprint of key which should be used for signing or key alias\",\n)\n@click.option(\n    \"--signing-key-name\",\n    required=False,\n    multiple=True,\n    help=\"signing key name\",\n)\n@click.option(\"--task-id\", required=True, help=\"Task id identifier (usually pub task-id)\")\n@click.option(\"--config-file\", default=CONFIG_PATHS[0], help=\"path to the config file\")\n@click.option(\n    \"--digest\",\n    required=True,\n    multiple=True,\n    type=str,\n    help=\"Digests which should be signed.\",\n)\n@click.option(\n    \"--reference\",\n    required=True,\n    multiple=True,\n    type=str,\n    help=\"References which should be signed.\",\n)\n@click.option(\n    \"--requester\",\n    required=False,\n    multiple=False,\n    type=str,\n    help=\"Use this requester instead one from certificate file.\",\n)\n@click.option(\"--raw\", default=False, is_flag=True, help=\"Print raw output instead of json\")\n@click.option(\n    \"--log-level\",\n    type=click.Choice([\"DEBUG\", \"INFO\", \"WARNING\", \"ERROR\"]),\n    default=\"INFO\",\n    help=\"Set log level\",\n)\n@click.option(\n    \"--signer-type\", type=click.Choice([\"single\", \"batch\"]), default=\"single\", help=\"Signer type\"\n)\ndef msg_container_sign_main(\n    signing_key: List[str] = [],\n    signing_key_name: List[str] = [],\n    task_id: str = \"\",\n    config_file: str = \"\",\n    digest: List[str] = [],\n    reference: List[str] = [],\n    requester: str = \"\",\n    raw: bool = False,\n    log_level: str = \"INFO\",\n    signer_type: str = \"single\",\n) -&gt; None:\n    \"\"\"Entry point method for containersign operation.\n\n    Print following json output on stdout when `--raw` is set:\n\n    {\n        \"signer_result\": [pubtools.sign.signers.msgsigner.MsgSignerResults][],\n        \"operation_results\": [pubtools.sign.results.containersign.ContainerSignResult][],\n        \"operation\": [pubtools.sign.operations.containersign.ContainerSignOperation][],\n        \"signing_keys\": [\"signing_key_id\"]\n    }\n\n    Otherwise prints one signed claim per line if sucessfull or error messages if not\n    \"\"\"\n    ch = logging.StreamHandler()\n    ch.setLevel(getattr(logging, sanitize_log_level(log_level)))\n    LOG.addHandler(ch)\n    logging.basicConfig(level=getattr(logging, sanitize_log_level(log_level)))\n\n    ret = msg_container_sign(\n        signing_keys=signing_key,\n        signing_key_names=signing_key_name,\n        task_id=task_id,\n        config_file=config_file,\n        digest=digest,\n        reference=reference,\n        requester=requester,\n        signer_type=signer_type,\n    )\n    if not raw:\n        click.echo(json.dumps(ret))\n        if ret[\"signer_result\"][\"status\"] == \"error\":\n            sys.exit(1)\n    else:\n        for claim in ret[\"operation_results\"]:\n            if claim[0][\"msg\"][\"errors\"]:\n                for error in claim[0][\"msg\"][\"errors\"]:\n                    print(error, file=sys.stderr)\n                sys.exit(1)\n            else:\n                print(claim[0][\"msg\"][\"signed_claim\"])\n</code></pre>"},{"location":"user-guide/clear-sign/","title":"Clear sign","text":""},{"location":"user-guide/clear-sign/#clearsign","title":"Clearsign","text":""},{"location":"user-guide/clear-sign/#messaging-signer","title":"Messaging signer","text":"<p>Messaging signer works as client which communicates with the server via messaging bus. User data to be signed are wrapped into signing requests and sent to the server. The server replies with  signed requests which are composed from the original signing request and the signature. Signature is base64 encoded clearsign of user data.</p>"},{"location":"user-guide/cli-commands/","title":"CLI Commands","text":""},{"location":"user-guide/cli-commands/#cli-commands","title":"CLI Commands","text":""},{"location":"user-guide/cli-commands/#pubtools-sign-msg-container-sign_1","title":"pubtools-sign-msg-container-sign","text":""},{"location":"user-guide/cli-commands/#pubtools-sign-msg-container-sign","title":"pubtools-sign-msg-container-sign","text":"<p>Entry point method for containersign operation.</p> <p>Print following json output on stdout when <code>--raw</code> is set:</p> <p>{     \"signer_result\": pubtools.sign.signers.msgsigner.MsgSignerResults,     \"operation_results\": pubtools.sign.results.containersign.ContainerSignResult,     \"operation\": pubtools.sign.operations.containersign.ContainerSignOperation,     \"signing_keys\": [\"signing_key_id\"] }</p> <p>Otherwise prints one signed claim per line if sucessfull or error messages if not</p> <p>Usage:</p> <pre><code>pubtools-sign-msg-container-sign [OPTIONS]\n</code></pre> <p>Options:</p> <pre><code>  --signing-key TEXT              8 characters key fingerprint of key which\n                                  should be used for signing or key alias\n                                  [required]\n  --signing-key-name TEXT         signing key name\n  --task-id TEXT                  Task id identifier (usually pub task-id)\n                                  [required]\n  --config-file TEXT              path to the config file\n  --digest TEXT                   Digests which should be signed.  [required]\n  --reference TEXT                References which should be signed.\n                                  [required]\n  --requester TEXT                Use this requester instead one from\n                                  certificate file.\n  --raw                           Print raw output instead of json\n  --log-level [DEBUG|INFO|WARNING|ERROR]\n                                  Set log level\n  --signer-type [single|batch]    Signer type\n  --help                          Show this message and exit.\n</code></pre>"},{"location":"user-guide/cli-commands/#pubtools-sign-cosign-container-sign_1","title":"pubtools-sign-cosign-container-sign","text":""},{"location":"user-guide/cli-commands/#pubtools-sign-cosign-container-sign","title":"pubtools-sign-cosign-container-sign","text":"<p>Entry point method for containersign operation.</p> <p>Usage:</p> <pre><code>pubtools-sign-cosign-container-sign [OPTIONS]\n</code></pre> <p>Options:</p> <pre><code>  --signing-key TEXT  signing key used by cosign.  [required]\n  --config-file TEXT  path to the config file\n  --digest TEXT       Digests which should be signed.  [required]\n  --reference TEXT    References which should be signed.\n  --identity TEXT     Identity reference.\n  --raw               Print raw output instead of json\n  --help              Show this message and exit.\n</code></pre>"},{"location":"user-guide/cli-commands/#pubtools-sign-msg-clear-sign_1","title":"pubtools-sign-msg-clear-sign","text":""},{"location":"user-guide/cli-commands/#pubtools-sign-msg-clear-sign","title":"pubtools-sign-msg-clear-sign","text":"<p>Entry point method for clearsign operation.</p> <p>Print following json output on stdout if <code>--raw</code> is set:</p> <p>{     \"signer_result\": pubtools.sign.signers.msgsigner.MsgSignerResults,     \"operation_results\": pubtools.sign.results.clearsign.ClearSignResult,     \"operation\": pubtools.sign.operations.clearsign.ClearSignOperation,     \"signing_key\": \"signing_key_id\"   }</p> <p>Otherwise prints one clearsigned output per line if sucessfull or error messages if not</p> <p>Usage:</p> <pre><code>pubtools-sign-msg-clear-sign [OPTIONS] [INPUTS]...\n</code></pre> <p>Options:</p> <pre><code>  --signing-key TEXT              8 characters key fingerprint of key which\n                                  should be used for signing or key alias\n                                  [required]\n  --task-id TEXT                  Task id identifier (usually pub task-id)\n                                  [required]\n  --config-file TEXT              path to the config file\n  --raw                           Print raw output instead of json\n  --log-level [DEBUG|INFO|WARNING|ERROR]\n                                  Set log level\n  --requester TEXT                Use this requester instead one from\n                                  certificate file.\n  --repo TEXT                     Repository reference\n  --help                          Show this message and exit.\n</code></pre>"},{"location":"user-guide/cli-commands/#pubtools-sign-multi-command-bundle","title":"pubtools-sign multi command bundle","text":""},{"location":"user-guide/cli-commands/#pubtools-sign","title":"pubtools-sign","text":"<p>Pubtools-sign multi command bundle.</p> <p>Usage:</p> <pre><code>pubtools-sign [OPTIONS] COMMAND [ARGS]...\n</code></pre> <p>Options:</p> <pre><code>  --help  Show this message and exit.\n</code></pre>"},{"location":"user-guide/cli-commands/#pubtools-sign-cosign-container-sign-main","title":"pubtools-sign cosign-container-sign-main","text":"<p>Entry point method for containersign operation.</p> <p>Usage:</p> <pre><code>pubtools-sign cosign-container-sign-main [OPTIONS]\n</code></pre> <p>Options:</p> <pre><code>  --signing-key TEXT  signing key used by cosign.  [required]\n  --config-file TEXT  path to the config file\n  --digest TEXT       Digests which should be signed.  [required]\n  --reference TEXT    References which should be signed.\n  --identity TEXT     Identity reference.\n  --raw               Print raw output instead of json\n  --help              Show this message and exit.\n</code></pre>"},{"location":"user-guide/cli-commands/#pubtools-sign-msg-clear-sign-main","title":"pubtools-sign msg-clear-sign-main","text":"<p>Entry point method for clearsign operation.</p> <p>Print following json output on stdout if <code>--raw</code> is set:</p> <p>{     \"signer_result\": pubtools.sign.signers.msgsigner.MsgSignerResults,     \"operation_results\": pubtools.sign.results.clearsign.ClearSignResult,     \"operation\": pubtools.sign.operations.clearsign.ClearSignOperation,     \"signing_key\": \"signing_key_id\"   }</p> <p>Otherwise prints one clearsigned output per line if sucessfull or error messages if not</p> <p>Usage:</p> <pre><code>pubtools-sign msg-clear-sign-main [OPTIONS] [INPUTS]...\n</code></pre> <p>Options:</p> <pre><code>  --signing-key TEXT              8 characters key fingerprint of key which\n                                  should be used for signing or key alias\n                                  [required]\n  --task-id TEXT                  Task id identifier (usually pub task-id)\n                                  [required]\n  --config-file TEXT              path to the config file\n  --raw                           Print raw output instead of json\n  --log-level [DEBUG|INFO|WARNING|ERROR]\n                                  Set log level\n  --requester TEXT                Use this requester instead one from\n                                  certificate file.\n  --repo TEXT                     Repository reference\n  --help                          Show this message and exit.\n</code></pre>"},{"location":"user-guide/cli-commands/#pubtools-sign-msg-container-sign-main","title":"pubtools-sign msg-container-sign-main","text":"<p>Entry point method for containersign operation.</p> <p>Print following json output on stdout when <code>--raw</code> is set:</p> <p>{     \"signer_result\": pubtools.sign.signers.msgsigner.MsgSignerResults,     \"operation_results\": pubtools.sign.results.containersign.ContainerSignResult,     \"operation\": pubtools.sign.operations.containersign.ContainerSignOperation,     \"signing_keys\": [\"signing_key_id\"] }</p> <p>Otherwise prints one signed claim per line if sucessfull or error messages if not</p> <p>Usage:</p> <pre><code>pubtools-sign msg-container-sign-main [OPTIONS]\n</code></pre> <p>Options:</p> <pre><code>  --signing-key TEXT              8 characters key fingerprint of key which\n                                  should be used for signing or key alias\n                                  [required]\n  --signing-key-name TEXT         signing key name\n  --task-id TEXT                  Task id identifier (usually pub task-id)\n                                  [required]\n  --config-file TEXT              path to the config file\n  --digest TEXT                   Digests which should be signed.  [required]\n  --reference TEXT                References which should be signed.\n                                  [required]\n  --requester TEXT                Use this requester instead one from\n                                  certificate file.\n  --raw                           Print raw output instead of json\n  --log-level [DEBUG|INFO|WARNING|ERROR]\n                                  Set log level\n  --signer-type [single|batch]    Signer type\n  --help                          Show this message and exit.\n</code></pre>"},{"location":"user-guide/config/","title":"Configuration file","text":""},{"location":"user-guide/config/#configuration-file","title":"Configuration file","text":"<p>Here's an example configuration file for a service that uses the <code>msg_signer</code> and <code>cosign_signer</code> components. This file is structured in YAML format.</p> <pre><code>msg_signer:\n  messaging_brokers:\n    - amqps://&lt;your-broker&gt;:5671\n  messaging_cert_key: &lt;path-to-ssl-certificate-and-key&gt; \n  messaging_ca_cert: &lt;path-to-ca-certificate&gt;\n  topic_send_to: topic://&lt;topic-where-you-want-to-send-signing-requests&gt;\n  topic_listen_to: queue://&lt;topic-where-signing-server-sends-signed-requests&gt; (see section bellow)\n  environment: &lt;&gt;your-environment-id&gt;\n  service: &lt;id-of-service-which-sends-signing-request&gt; \n  timeout: &lt;integer-timeout-for-receiving-message&gt;\n  retries: &lt;integer-number-of-retries-for-receiving-messages&gt;\n  send_retries: &lt;integer-number-of-retries-for-sending-messages&gt;\n  message_id_key: &lt;attribute-in-signed-request-which-identifies-the-request&gt;\n  log_level: &lt;log-level&gt;\n  key_aliases:\n    &lt;alias&gt;: &lt;real-signing-key&gt;\nmsg_batch_signer:\n  messaging_brokers:\n    - amqps://&lt;your-broker&gt;:5671\n  messaging_cert_key: &lt;path-to-ssl-certificate-and-key&gt; \n  messaging_ca_cert: &lt;path-to-ca-certificate&gt;\n  topic_send_to: topic://&lt;topic-where-you-want-to-send-signing-requests&gt;\n  topic_listen_to: queue://&lt;topic-where-signing-server-sends-signed-requests&gt; (see section bellow)\n  environment: &lt;&gt;your-environment-id&gt;\n  service: &lt;id-of-service-which-sends-signing-request&gt; \n  timeout: &lt;integer-timeout-for-receiving-message&gt;\n  retries: &lt;integer-number-of-retries-for-receiving-messages&gt;\n  send_retries: &lt;integer-number-of-retries-for-sending-messages&gt;\n  message_id_key: &lt;attribute-in-signed-request-which-identifies-the-request&gt;\n  log_level: &lt;log-level&gt;\n  key_aliases:\n    &lt;alias&gt;: &lt;real-signing-key&gt;\n  chunk_size: 200\ncosign_signer:\n  rekor_url: &lt;rekor-url&gt;\n  upload_tlog: &lt;upload-tlog&gt; \n  registry_user: &lt;docker-registry-user-where-signatures-will-be-stored&gt;\n  registry_password: &lt;docker-registry-password&gt; \n  log_level: &lt;log-level&gt;\n  env_variables:\n    &lt;ENV&gt;: &lt;value&gt;\n    # any additional environment variables you want to set for cosign\n  key_aliases:\n    &lt;alias&gt;: &lt;real-signing-key&gt;\n</code></pre>"},{"location":"user-guide/config/#configuration-details","title":"Configuration details","text":"<ul> <li>Messaging signer <code>topic_listen_to</code> attribute also supports templating attributes {creator}    and {task_id}. Creator is UID or CN fetched from the client ceritificate or provided   on the input by user. Task id is any user provided string which servers to identify the message.</li> </ul> <p>To read more about signer you can check the Messaging Signer  and  Cosign signer documentation.</p>"},{"location":"user-guide/container-signing/","title":"Containers signing","text":""},{"location":"user-guide/container-signing/#containers-signing","title":"Containers signing","text":""},{"location":"user-guide/container-signing/#messaging-signer","title":"Messaging signer","text":"<p>Messaging signer works as client which communicates with the server via messaging bus. User data to be signed are wrapped into signing requests and sent to the server. The server replies with  signed requests which are composed from the original signing request and the JSON signature encrypted by gpg and base64 encoded. (See Atomic signature JSON data format).</p> <p>Signature then needs to be uploaded to signature store. Tooling for that is not included in this project as it may vary depending on the signature store implementation.</p>"},{"location":"user-guide/container-signing/#validation","title":"Validation","text":"<p>Signatures are served by sigstore via following api: <code>https://sigstore.com/&lt;any-extra-path&gt;/&lt;container-image-name&gt;@sha256=&lt;container-image-digest&gt;/signature-&lt;N&gt;</code> where <code>N</code> is positive integer starting from 1. Validation of the container image is shown in the following diagram</p> <pre><code>sequenceDiagram\n  autonumber\n  Client-&gt;&gt;Registry: Pull a container image\n  Note left of Client: sets N to 1\n  loop\n    Client-&gt;&gt;Sigstore: pull signature N from the signature store\n    alt Signature is valid according to validation policy\n        Note right of Client: Finished validation\n    else Signature is not valid\n        Note right of Client: increate N by 1 and continue the cycle\n    else No more signatures (404 returned)\n        Note right of Client: Validation failed, no valid signature found\n    end\n  end</code></pre> <p>Validation policy is defined in <code>/etc/containers/policy.json</code>. To lean more about validation policies you can check [https://github.com/containers/image/blob/main/docs/containers-policy.json.5.md#policy-requirements]. Here's exapmle of policy.json set to validate signatures for <code>registry.redhat.io</code> </p><pre><code>{\n    \"default\": [\n        {\n            \"type\": \"insecureAcceptAnything\"\n        }\n    ],\n    \"transports\": {\n        \"docker\": {\n            \"registry.redhat.io\": [\n                {\n                    \"type\": \"signedBy\",\n                    \"keyType\": \"GPGKeys\",\n                    \"keyPath\": \"/etc/pki/rpm-gpg/RPM-GPG-KEY-redhat-release\",\n                    \"signedIdentity\": {\n                        \"type\": \"matchRepoDigestOrExact\"\n                    }\n                }\n            ]\n        },\n        \"docker-daemon\": {\n            \"\": [\n                {\n                    \"type\": \"insecureAcceptAnything\"\n                }\n            ]\n        }\n    }\n}\n</code></pre> On top of that you need to configure the registry access in <code>/etc/containers/registries.d/</code> on client machine. Here's example of configuration file <code>registry.redhat.io.yaml</code>: <pre><code>docker:\n  registry.redhat.io:\n    sigstore: https://registry.redhat.io/containers/sigstore\n</code></pre> The <code>sigstore</code> attribute is base url to the sigstore server as mentioned above <code>https://sigstore.com/&lt;any-extra-path&gt;/</code>.<p></p>"},{"location":"user-guide/container-signing/#example","title":"Example","text":"<pre><code>pubtools-sign-msg-container-sign \\\n    --signing-key testing \\\n    --config-file ~/.config/pubtools-sign/conf-hacbs.yaml \\\n    --reference registry.redhat.io/ubi9/ubi:latest \\\n    --digest sha256:1d15a69724bdf0fba6fda9baaf5f3e10e562324964d0c12664f4412f549b755d \\\n    --task-id 32e729ee-62ae-4d17-b067-d86f6d89939f\n</code></pre>"},{"location":"user-guide/container-signing/#batch-signing","title":"Batch signing","text":"<p>New type of signing request is supported for batch signing. It allows to sign multiple container images. You can specify multiple <code>--reference</code> and <code>--digest</code> arguments which will be splitted into batches and signed with all provided signing keys.</p> <pre><code>pubtools-sign-msg-container-sign \\\n    --signing-key testing \\\n    --config-file ~/.config/pubtools-sign/conf-hacbs.yaml \\\n    --reference registry.redhat.io/ubi9/ubi:latest \\\n    --reference registry.redhat.io/ubi9/ubi:9 \\\n    --reference registry.redhat.io/ubi9/ubi:9.1 \\\n    --digest sha256:1d15a69724bdf0fba6fda9baaf5f3e10e562324964d0c12664f4412f549b755d \\\n    --digest sha256:1d15a69724bdf0fba6fda9baaf5f3e10e562324964d0c12664f4412f549b755d \\\n    --digest sha256:1d15a69724bdf0fba6fda9baaf5f3e10e562324964d0c12664f4412f549b755d \\\n    --task-id 32e729ee-62ae-4d17-b067-d86f6d89939f \\\n    --signer-type batch\n</code></pre>"},{"location":"user-guide/container-signing/#cosign-signer","title":"Cosign signer","text":""},{"location":"user-guide/container-signing/#validation_1","title":"Validation","text":"<p>Validation of signatures signed by cosign can be done in two ways:</p>"},{"location":"user-guide/container-signing/#cosign-verify","title":"Cosign verify","text":"<p>You can use <code>cosign</code> binary to validate the signature. The command is as follows: </p><pre><code>cosign verify &lt;IMAGE&gt;\n</code></pre><p></p>"},{"location":"user-guide/container-signing/#validation-during-podmandocker-pull","title":"Validation during podman/docker pull","text":"<p>You can configure registry on the client machine to use use sigstore attachements. Here's example: </p><pre><code>docker:\n  registry.redhat.io:\n    use-sigstore-attachments: true\n</code></pre><p></p>"},{"location":"user-guide/user-guide/","title":"User guide","text":""},{"location":"user-guide/user-guide/#user-guide","title":"User guide","text":"<p>Before you start reading further: </p> <ul> <li>Check out available CLI commands in CLI Commands for signing.</li> <li>Check out Configuration for details on how to configure the signers.</li> </ul> <p>Bellow you find details about supported signatures and signers. How they work and how you can validate signatures produces by them.</p> <ul> <li>Clearsign</li> <li>Containers Signing</li> </ul>"},{"location":"user-guide/signers/cosign-signer/","title":"Cosign signer details","text":""},{"location":"user-guide/signers/cosign-signer/#cosign-signer-details","title":"Cosign signer details","text":"<p>Cosign signer use cosign project to sign container images and other artifacts.</p> <pre><code>sequenceDiagram\n  autonumber\n  Client-&gt;&gt;Cosign binary: Request to sign container\n  Cosign binary-&gt;&gt;Container registry: Upload signature to desired container image\n  Note right of Cosign binary: Optionally\n  Cosign binary-&gt;&gt;Rekor: Upload signing record to transparency log</code></pre>"},{"location":"user-guide/signers/cosign-signer/#configuration","title":"Configuration","text":"<p>Cosign signer is configured using the <code>cosign_signer</code> section in the <code>config.yaml</code> file. Check Configuration for details.  Cosign signer requires the following configuration fields to be present in a configuration file:</p>"},{"location":"user-guide/signers/cosign-signer/#rekor_url","title":"rekor_url","text":"<p>The URL of the Rekor transparency log server where the signing records will be uploaded. This is used to ensure the integrity and transparency of the signing process.</p>"},{"location":"user-guide/signers/cosign-signer/#upload_tlog","title":"upload_tlog","text":"<p>A boolean value indicating whether to upload the signing record to the transparency log. If set to <code>true</code>, the signing record will be uploaded to the Rekor server.</p>"},{"location":"user-guide/signers/cosign-signer/#registry_user","title":"registry_user","text":"<p>The username for the Docker registry where the signatures will be stored. This is used for authentication when pushing the signed artifacts to the registry.</p>"},{"location":"user-guide/signers/cosign-signer/#registry_password","title":"registry_password","text":"<p>The password for the Docker registry where the signatures will be stored. This is used for authentication when pushing the signed artifacts to the registry.</p>"},{"location":"user-guide/signers/cosign-signer/#log_level","title":"log_level","text":"<p>The log level for the cosign signer. This can be set to <code>DEBUG</code>, <code>INFO</code>, <code>WARNING</code>, <code>ERROR</code>, or <code>CRITICAL</code> depending on the desired verbosity of the logs.</p>"},{"location":"user-guide/signers/cosign-signer/#env_variables","title":"env_variables","text":"<p>A dictionary of environment variables that will be set for the cosign binary when it is executed. This can include any additional environment variables required for the signing process.</p>"},{"location":"user-guide/signers/cosign-signer/#key_aliases","title":"key_aliases","text":"<p>A dictionary of key aliases that map to the real signing keys. This allows for easier management of signing keys, especially when using multiple keys for different purposes. You can also use same key for different signers.</p>"},{"location":"user-guide/signers/msg-signer/","title":"Messaging signer details","text":""},{"location":"user-guide/signers/msg-signer/#messaging-signer-details","title":"Messaging signer details","text":"<p>Messaging signer sends messages over over configured messaging protocol (AMQP, MQTT, etc.) to messaging broker. In this workflow, it's expected a signing server listens for messages on a specific topic or queue, and processes them accordingly. See the diagram bellow</p> <pre><code>sequenceDiagram\n  autonumber\n  Client-&gt;&gt;Broker: Send signing request\n  Broker-&gt;&gt;Signing server: Forward request\n  Signing server--&gt;&gt;Broker: Send signed request\n  Broker--&gt;&gt;Client: Deliver signed request</code></pre>"},{"location":"user-guide/signers/msg-signer/#configuration","title":"Configuration","text":"<p>Messaging signer is configured in the <code>config.yaml</code> file under the <code>msg_signer</code> section. Check Configuration for details. Messaging signer requires following configuration fields to be present in a configuration file:</p>"},{"location":"user-guide/signers/msg-signer/#messaging_brokers","title":"messaging_brokers","text":"<p>List of messaging brokers to connect to. It can be a list of AMQP or AMQPS. Brokers are required to be written in fully specified url like: <code>amqps://&lt;your-broker&gt;:5671</code></p>"},{"location":"user-guide/signers/msg-signer/#messaging_cert_key","title":"messaging_cert_key","text":"<p>Path to a file containging certificate and key in PEM format used for authentication with the messaging broker (only for AMQPS).</p>"},{"location":"user-guide/signers/msg-signer/#messaging_ca_cert","title":"messaging_ca_cert","text":"<p>Path to a file containing CA certificate in PEM format used for verifying the messaging broker's certificate (only for AMQPS).</p>"},{"location":"user-guide/signers/msg-signer/#topic_send_to","title":"topic_send_to","text":"<p>The topic where the signing requests will be sent. Example: <code>topic://&lt;topic-where-you-want-to-send-signing-requests&gt;</code>.</p>"},{"location":"user-guide/signers/msg-signer/#topic_listen_to","title":"topic_listen_to","text":"<p>The topic or queue where the signing server sends signed requests. This can be a queue or topic URL, such as <code>queue://&lt;topic-where-signing-server-sends-signed-requests&gt;</code>. This field supports templating attributes <code>{creator}</code> and <code>{task_id}</code>. The <code>creator</code> is the UID or CN fetched from the client certificate or provided on the input by the user. The <code>task_id</code> is any user-provided string that serves to identify the message.</p>"},{"location":"user-guide/signers/msg-signer/#environment","title":"environment","text":"<p>The environment name for which the signing requests are being processed. This is typically a unique identifier for the environment, such as <code>production</code>, <code>staging</code>, etc. This field is used in composed signigng request and its measning depends only on the signing server implementation.</p>"},{"location":"user-guide/signers/msg-signer/#service","title":"service","text":"<p>The ID of the service that sends the signing request. This is used to identify the service in the signing process.It depends on the signing server implementation.</p>"},{"location":"user-guide/signers/msg-signer/#timeout","title":"timeout","text":"<p>The timeout in seconds for receiving messages from the messaging broker. See the diagram bellow to  understand how it works.</p>"},{"location":"user-guide/signers/msg-signer/#retries","title":"retries","text":"<p>The number of retries for receiving messages from the messaging broker. If a message is not received within the timeout, it will be retried this many times. See the diagram bellow to understand how it works.</p>"},{"location":"user-guide/signers/msg-signer/#send_retries","title":"send_retries","text":"<p>Number of retries for repeating send-receive cycle. See the diagram bellow to understand how it works.</p>"},{"location":"user-guide/signers/msg-signer/#message_id_key","title":"message_id_key","text":"<p>The attribute in the signed request that identifies the request. This is used to correlate the signed request with the original signing request.</p>"},{"location":"user-guide/signers/msg-signer/#log_level","title":"log_level","text":"<p>The log level for the messaging signer. This can be set to <code>DEBUG</code>, <code>INFO</code>, <code>WARNING</code>, <code>ERROR</code>, or <code>CRITICAL</code> depending on the desired verbosity of the logs.</p>"},{"location":"user-guide/signers/msg-signer/#key_aliases","title":"key_aliases","text":"<p>A dictionary of key aliases that map to the real signing keys. This allows for easier management of signing keys, especially when using multiple keys for different purposes. You can also use same key for different signers.</p>"},{"location":"user-guide/signers/msg-signer/#messaging-signer-workflow-of-send-and-retries","title":"Messaging signer workflow of send and retries","text":"<pre><code>sequenceDiagram\n  autonumber\n  loop Send-receive cycle\n    Note right of Client: Cycle repeats maximally `send_retries` times\n    Client-&gt;&gt;Signing server: Send all signing requests\n    loop Receive-cycle\n        Note right of Client: Cycle repeats maximally `retries` times\n        Note right of Client: Client listens on `topic_listen_to` for expected signed requests\n        Signing server--&gt;&gt;Client: Reply with a signed request\n        Note right of Client: If a expected signing request is received, `timeout` is reset.&lt;br/&gt;Otherwise, it fails with error and new iteration of receive cycle&lt;br/&gt;begins. Only unreceived signing requests are expected to be received.\n    end\n    Note right of Client: Every iteration of send cycle works only with unreceived signing requests.\n\n  end</code></pre>"}]}